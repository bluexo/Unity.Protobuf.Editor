<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Google.ProtocolBuffers</name>
    </assembly>
    <members>
        <member name="T:Google.ProtocolBuffers.AbstractBuilder`2">
            <summary>
            Implementation of the non-generic IMessage interface as far as possible.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.AbstractBuilderLite`2">
            <summary>
            Implementation of the non-generic IMessage interface as far as possible.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IBuilderLite`2">
            <summary>
            Interface implemented by Protocol Message builders.
            TODO(jonskeet): Consider "SetXXX" methods returning the builder, as well as the properties.
            </summary>
            <typeparam name="TMessage">Type of message</typeparam>
            <typeparam name="TBuilder">Type of builder</typeparam>
        </member>
        <member name="T:Google.ProtocolBuffers.IBuilderLite">
            <summary>
            Non-generic interface for all members whose signatures don't require knowledge of
            the type being built. The generic interface extends this one. Some methods return
            either an IBuilder or an IMessage; in these cases the generic interface redeclares
            the same method with a type-specific signature. Implementations are encouraged to
            use explicit interface implemenation for the non-generic form. This mirrors
            how IEnumerable and IEnumerable&lt;T&gt; work.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilderLite.IsInitialized">
            <summary>
            Returns true iff all required fields in the message and all
            embedded messages are set.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.Clear">
            <summary>
            Resets all fields to their default values.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Merge the specified other message which may be a different implementation of
            the same message descriptor.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.Build">
            <summary>
            Constructs the final message. Once this is called, this Builder instance
            is no longer valid, and calling any other method may throw a
            NullReferenceException. If you need to continue working with the builder
            after calling Build, call Clone first.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.UninitializedMessageException">the message
            is missing one or more required fields; use BuildPartial to bypass
            this check</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.BuildPartial">
            <summary>
            Like Build(), but does not throw an exception if the message is missing
            required fields. Instead, a partial message is returned.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.Clone">
            <summary>
            Clones this builder.
            TODO(jonskeet): Explain depth of clone.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(Google.ProtocolBuffers.ICodedInputStream)" -->
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Like MergeFrom(ICodedInputStream), but also parses extensions.
            The extensions that you want to be able to parse must be registered
            in <paramref name="extensionRegistry"/>. Extensions not in the registry
            will be treated as unknown fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeDelimitedFrom(System.IO.Stream)">
            <summary>
            Like MergeFrom(Stream), but does not read until the end of the file.
            Instead, the size of the message (encoded as a varint) is read first,
            then the message data. Use Message.WriteDelimitedTo(Stream) to
            write messages in this format.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeDelimitedFrom(System.IO.Stream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Like MergeDelimitedFrom(Stream) but supporting extensions.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(Google.ProtocolBuffers.ByteString)">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(Google.ProtocolBuffers.ByteString,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream, ExtensionRegistry).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(System.Byte[])">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(System.Byte[],Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream, ExtensionRegistry).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(System.IO.Stream)">
            <summary>
            Parse <paramref name="input"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream). Note that this method always reads
            the entire input (unless it throws an exception). If you want it to
            stop earlier, you will need to wrap the input in a wrapper
            stream which limits reading. Or, use IMessage.WriteDelimitedTo(Stream)
            to write your message and MmergeDelimitedFrom(Stream) to read it.
            Despite usually reading the entire stream, this method never closes the stream. 
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilderLite`2.MergeFrom(System.IO.Stream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="input"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream, ExtensionRegistry).
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilderLite`2.DefaultInstanceForType">
            <summary>
            Get's the message's type's default instance.
            <see cref="P:Google.ProtocolBuffers.IMessageLite`1.DefaultInstanceForType"/>
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.AbstractBuilderLite`2.LimitedInputStream">
            <summary>
            Stream implementation which proxies another stream, only allowing a certain amount
            of data to be read. Note that this is only used to read delimited streams, so it
            doesn't attempt to implement everything.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IBuilder`2">
            <summary>
            Interface implemented by Protocol Message builders.
            TODO(jonskeet): Consider "SetXXX" methods returning the builder, as well as the properties.
            </summary>
            <typeparam name="TMessage">Type of message</typeparam>
            <typeparam name="TBuilder">Type of builder</typeparam>
        </member>
        <member name="T:Google.ProtocolBuffers.IBuilder">
            <summary>
            Non-generic interface for all members whose signatures don't require knowledge of
            the type being built. The generic interface extends this one. Some methods return
            either an IBuilder or an IMessage; in these cases the generic interface redeclares
            the same method with a type-specific signature. Implementations are encouraged to
            use explicit interface implemenation for the non-generic form. This mirrors
            how IEnumerable and IEnumerable&lt;T&gt; work.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder.SetField(Google.ProtocolBuffers.Descriptors.FieldDescriptor,System.Object)">
            <summary>
            Only present in the nongeneric interface - useful for tests, but
            not as much in real life.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder.SetRepeatedField(Google.ProtocolBuffers.Descriptors.FieldDescriptor,System.Int32,System.Object)">
            <summary>
            Only present in the nongeneric interface - useful for tests, but
            not as much in real life.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder.GetRepeatedFieldCount(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            <see cref="!:IMessage&lt;TMessage, TBuilder&gt;.GetRepeatedFieldCount"/>
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder.HasField(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            <see cref="!:IMessage&lt;TMessage, TBuilder&gt;.HasField"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder.CreateBuilderForField(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Create a builder for messages of the appropriate type for the given field.
            Messages built with this can then be passed to the various mutation properties
            and methods.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilder.IsInitialized">
            <summary>
            Returns true iff all required fields in the message and all
            embedded messages are set.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilder.AllFields">
            <summary>
            Behaves like the equivalent property in IMessage&lt;T&gt;.
            The returned map may or may not reflect future changes to the builder.
            Either way, the returned map is unmodifiable.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilder.Item(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Allows getting and setting of a field.
            <see cref="!:IMessage&lt;TMessage, TBuilder&gt;.Item(FieldDescriptor)"/>
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilder.DescriptorForType">
            <summary>
            Get the message's type descriptor.
            <see cref="!:IMessage&lt;TMessage, TBuilder&gt;.DescriptorForType"/>
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilder.Item(Google.ProtocolBuffers.Descriptors.FieldDescriptor,System.Int32)">
            <summary>
            Allows getting and setting of a repeated field value.
            <see cref="!:IMessage&lt;TMessage, TBuilder&gt;.Item(FieldDescriptor, int)"/>
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilder.UnknownFields">
            <summary>
            <see cref="!:IMessage&lt;TMessage, TBuilder&gt;.UnknownFields"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.Clear">
            <summary>
            Resets all fields to their default values.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(Google.ProtocolBuffers.IMessage)">
            <summary>
            Merge the specified other message which may be a different implementation of
            the same message descriptor.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.Build">
            <summary>
            Constructs the final message. Once this is called, this Builder instance
            is no longer valid, and calling any other method may throw a
            NullReferenceException. If you need to continue working with the builder
            after calling Build, call Clone first.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.UninitializedMessageException">the message
            is missing one or more required fields; use BuildPartial to bypass
            this check</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.BuildPartial">
            <summary>
            Like Build(), but does not throw an exception if the message is missing
            required fields. Instead, a partial message is returned.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.Clone">
            <summary>
            Clones this builder.
            TODO(jonskeet): Explain depth of clone.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(Google.ProtocolBuffers.ICodedInputStream)" -->
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Like MergeFrom(ICodedInputStream), but also parses extensions.
            The extensions that you want to be able to parse must be registered
            in <paramref name="extensionRegistry"/>. Extensions not in the registry
            will be treated as unknown fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.ClearField(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Clears the field. This is exactly equivalent to calling the generated
            Clear method corresponding to the field.
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.AddRepeatedField(Google.ProtocolBuffers.Descriptors.FieldDescriptor,System.Object)">
            <summary>
            Appends the given value as a new element for the specified repeated field.
            </summary>
            <exception cref="T:System.ArgumentException">the field is not a repeated field,
            the field does not belong to this builder's type, or the value is
            of the incorrect type
            </exception>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeUnknownFields(Google.ProtocolBuffers.UnknownFieldSet)">
            <summary>
            Merge some unknown fields into the set for this message.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeDelimitedFrom(System.IO.Stream)">
            <summary>
            Like MergeFrom(Stream), but does not read until the end of the file.
            Instead, the size of the message (encoded as a varint) is read first,
            then the message data. Use Message.WriteDelimitedTo(Stream) to
            write messages in this format.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeDelimitedFrom(System.IO.Stream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Like MergeDelimitedFrom(Stream) but supporting extensions.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(Google.ProtocolBuffers.ByteString)">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(Google.ProtocolBuffers.ByteString,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream, extensionRegistry).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(System.Byte[])">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(System.Byte[],Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="data"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream, extensionRegistry).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(System.IO.Stream)">
            <summary>
            Parse <paramref name="input"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream). Note that this method always reads
            the entire input (unless it throws an exception). If you want it to
            stop earlier, you will need to wrap the input in a wrapper
            stream which limits reading. Or, use IMessage.WriteDelimitedTo(Stream)
            to write your message and MmergeDelimitedFrom(Stream) to read it.
            Despite usually reading the entire stream, this method never closes the stream. 
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IBuilder`2.MergeFrom(System.IO.Stream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="input"/> as a message of this type and merge
            it with the message being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream, extensionRegistry).
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IBuilder`2.DefaultInstanceForType">
            <summary>
            Get's the message's type's default instance.
            <see cref="P:Google.ProtocolBuffers.IMessage`1.DefaultInstanceForType"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractBuilder`2.MergeFrom(`0)">
            <summary>
            Merge the specified other message into the message being
            built. Merging occurs as follows. For each field:
            For singular primitive fields, if the field is set in <paramref name="other"/>,
            then <paramref name="other"/>'s value overwrites the value in this message.
            For singular message fields, if the field is set in <paramref name="other"/>,
            it is merged into the corresponding sub-message of this message using the same
            merging rules.
            For repeated fields, the elements in <paramref name="other"/> are concatenated
            with the elements in this message.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractBuilder`2.ToString">
            <summary>
            Converts this builder to a string using <see cref="T:Google.ProtocolBuffers.TextFormat"/>.
            </summary>
            <remarks>
            This method is not sealed (in the way that it is in <see cref="T:Google.ProtocolBuffers.AbstractMessage`2"/>
            as it was added after earlier releases; some other implementations may already be overriding the
            method.
            </remarks>
        </member>
        <member name="T:Google.ProtocolBuffers.AbstractMessage`2">
            <summary>
            Implementation of the non-generic IMessage interface as far as possible.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.AbstractMessageLite`2">
            <summary>
            Implementation of the non-generic IMessage interface as far as possible.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IMessageLite`2">
            <summary>
            Type-safe interface for all generated messages to implement.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IMessageLite">
            <summary>
            Non-generic interface used for all parts of the API which don't require
            any type knowledge.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.WriteTo(Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Serializes the message and writes it to the given output stream.
            This does not flush or close the stream.
            </summary>
            <remarks>
            Protocol Buffers are not self-delimiting. Therefore, if you write
            any more data to the stream after the message, you must somehow ensure
            that the parser on the receiving end does not interpret this as being
            part of the protocol message. One way of doing this is by writing the size
            of the message before the data, then making sure you limit the input to
            that size when receiving the data. Alternatively, use WriteDelimitedTo(Stream).
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.WriteDelimitedTo(System.IO.Stream)">
            <summary>
            Like WriteTo(Stream) but writes the size of the message as a varint before
            writing the data. This allows more data to be written to the stream after the
            message without the need to delimit the message data yourself. Use 
            IBuilder.MergeDelimitedFrom(Stream) or the static method
            YourMessageType.ParseDelimitedFrom(Stream) to parse messages written by this method.
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.Equals(System.Object)">
            <summary>
            Compares the specified object with this message for equality.
            Returns true iff the given object is a message of the same type
            (as defined by DescriptorForType) and has identical values
            for all its fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.GetHashCode">
            <summary>
            Returns the hash code value for this message.
            TODO(jonskeet): Specify the hash algorithm, but better than the Java one!
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.ToString">
            <summary>
            Converts the message to a string in protocol buffer text format.
            This is just a trivial wrapper around TextFormat.PrintToString.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.PrintTo(System.IO.TextWriter)">
            <summary>
            Converts the message to a string.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.ToByteString">
            <summary>
            Serializes the message to a ByteString. This is a trivial wrapper
            around WriteTo(ICodedOutputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.ToByteArray">
            <summary>
            Serializes the message to a byte array. This is a trivial wrapper
            around WriteTo(ICodedOutputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.WriteTo(System.IO.Stream)">
            <summary>
            Serializes the message and writes it to the given stream.
            This is just a wrapper around WriteTo(ICodedOutputStream). This
            does not flush or close the stream.
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.WeakCreateBuilderForType">
            <summary>
            Creates a builder for the type, but in a weakly typed manner. This
            is typically implemented by strongly typed messages by just returning
            the result of CreateBuilderForType.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite.WeakToBuilder">
            <summary>
            Creates a builder with the same contents as this message. This
            is typically implemented by strongly typed messages by just returning
            the result of ToBuilder.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessageLite.IsInitialized">
            <summary>
            Returns true iff all required fields in the message and all embedded
            messages are set.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessageLite.SerializedSize">
            <summary>
            Returns the number of bytes required to encode this message.
            The result is only computed on the first call and memoized after that.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessageLite`1.DefaultInstanceForType">
            <summary>
            Returns an instance of this message type with all fields set to
            their default values. This may or may not be a singleton. This differs
            from the DefaultInstance property of each generated message class in that this
            method is an abstract method of IMessage whereas DefaultInstance is
            a static property of a specific class. They return the same thing.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite`2.CreateBuilderForType">
            <summary>
            Constructs a new builder for a message of the same type as this message.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessageLite`2.ToBuilder">
            <summary>
            Creates a builder with the same contents as this current instance.
            This is typically implemented by strongly typed messages by just
            returning the result of ToBuilder().
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractMessageLite`2.ToByteString">
            <summary>
            Serializes the message to a ByteString. This is a trivial wrapper
            around WriteTo(ICodedOutputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractMessageLite`2.ToByteArray">
            <summary>
            Serializes the message to a byte array. This is a trivial wrapper
            around WriteTo(ICodedOutputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractMessageLite`2.WriteTo(System.IO.Stream)">
            <summary>
            Serializes the message and writes it to the given stream.
            This is just a wrapper around WriteTo(CodedOutputStream). This
            does not flush or close the stream.
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractMessageLite`2.WriteDelimitedTo(System.IO.Stream)">
            <summary>
            Like WriteTo(Stream) but writes the size of the message as a varint before
            writing the data. This allows more data to be written to the stream after the
            message without the need to delimit the message data yourself. Use 
            IBuilder.MergeDelimitedFrom(Stream) or the static method
            YourMessageType.ParseDelimitedFrom(Stream) to parse messages written by this method.
            </summary>
            <param name="output"></param>
        </member>
        <member name="T:Google.ProtocolBuffers.IMessage`2">
            <summary>
            Type-safe interface for all generated messages to implement.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IMessage">
            <summary>
            Non-generic interface used for all parts of the API which don't require
            any type knowledge.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.HasField(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Returns true if the given field is set. This is exactly equivalent
            to calling the generated "Has" property corresponding to the field.
            </summary>
            <exception cref="T:System.ArgumentException">the field is a repeated field,
            or it's not a field of this type</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.GetRepeatedFieldCount(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Returns the number of elements of a repeated field. This is
            exactly equivalent to calling the generated "Count" property
            corresponding to the field.
            </summary>
            <exception cref="T:System.ArgumentException">the field is not a repeated field,
            or it's not a field of this type</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.WriteTo(Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Serializes the message and writes it to the given output stream.
            This does not flush or close the stream.
            </summary>
            <remarks>
            Protocol Buffers are not self-delimiting. Therefore, if you write
            any more data to the stream after the message, you must somehow ensure
            that the parser on the receiving end does not interpret this as being
            part of the protocol message. One way of doing this is by writing the size
            of the message before the data, then making sure you limit the input to
            that size when receiving the data. Alternatively, use WriteDelimitedTo(Stream).
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.WriteDelimitedTo(System.IO.Stream)">
            <summary>
            Like WriteTo(Stream) but writes the size of the message as a varint before
            writing the data. This allows more data to be written to the stream after the
            message without the need to delimit the message data yourself. Use 
            IBuilder.MergeDelimitedFrom(Stream) or the static method
            YourMessageType.ParseDelimitedFrom(Stream) to parse messages written by this method.
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.Equals(System.Object)">
            <summary>
            Compares the specified object with this message for equality.
            Returns true iff the given object is a message of the same type
            (as defined by DescriptorForType) and has identical values
            for all its fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.GetHashCode">
            <summary>
            Returns the hash code value for this message.
            TODO(jonskeet): Specify the hash algorithm, but better than the Java one!
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.ToString">
            <summary>
            Converts the message to a string in protocol buffer text format.
            This is just a trivial wrapper around TextFormat.PrintToString.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.ToByteString">
            <summary>
            Serializes the message to a ByteString. This is a trivial wrapper
            around WriteTo(ICodedOutputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.ToByteArray">
            <summary>
            Serializes the message to a byte array. This is a trivial wrapper
            around WriteTo(ICodedOutputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.WriteTo(System.IO.Stream)">
            <summary>
            Serializes the message and writes it to the given stream.
            This is just a wrapper around WriteTo(ICodedOutputStream). This
            does not flush or close the stream.
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.WeakCreateBuilderForType">
            <summary>
            Creates a builder for the type, but in a weakly typed manner. This
            is typically implemented by strongly typed messages by just returning
            the result of CreateBuilderForType.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage.WeakToBuilder">
            <summary>
            Creates a builder with the same contents as this message. This
            is typically implemented by strongly typed messages by just returning
            the result of ToBuilder.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage.DescriptorForType">
            <summary>
            Returns the message's type's descriptor. This differs from the
            Descriptor property of each generated message class in that this
            method is an abstract method of IMessage whereas Descriptor is
            a static property of a specific class. They return the same thing.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage.AllFields">
            <summary>
            Returns a collection of all the fields in this message which are set
            and their corresponding values.  A singular ("required" or "optional")
            field is set iff HasField() returns true for that field.  A "repeated"
            field is set iff GetRepeatedFieldSize() is greater than zero.  The
            values are exactly what would be returned by calling
            GetField(FieldDescriptor) for each field.  The map
            is guaranteed to be a sorted map, so iterating over it will return fields
            in order by field number. 
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage.Item(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Obtains the value of the given field, or the default value if
            it isn't set. For value type fields, the boxed value is returned.
            For enum fields, the EnumValueDescriptor for the enum is returned.
            For embedded message fields, the sub-message
            is returned. For repeated fields, an IList&lt;T&gt; is returned.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage.Item(Google.ProtocolBuffers.Descriptors.FieldDescriptor,System.Int32)">
            <summary>
            Gets an element of a repeated field. For value type fields 
            excluding enums, the boxed value is returned. For embedded
            message fields, the sub-message is returned. For enums, the
            relevant EnumValueDescriptor is returned.
            </summary>
            <exception cref="T:System.ArgumentException">the field is not a repeated field,
            or it's not a field of this type</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the index is out of
            range for the repeated field's value</exception>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage.UnknownFields">
            <summary>
            Returns the unknown fields for this message.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage.IsInitialized">
            <summary>
            Returns true iff all required fields in the message and all embedded
            messages are set.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage.SerializedSize">
            <summary>
            Returns the number of bytes required to encode this message.
            The result is only computed on the first call and memoized after that.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IMessage`1.DefaultInstanceForType">
            <summary>
            Returns an instance of this message type with all fields set to
            their default values. This may or may not be a singleton. This differs
            from the DefaultInstance property of each generated message class in that this
            method is an abstract method of IMessage whereas DefaultInstance is
            a static property of a specific class. They return the same thing.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage`2.CreateBuilderForType">
            <summary>
            Constructs a new builder for a message of the same type as this message.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IMessage`2.ToBuilder">
            <summary>
            Creates a builder with the same contents as this current instance.
            This is typically implemented by strongly typed messages by just
            returning the result of ToBuilder().
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.AbstractMessage`2.memoizedSize">
            <summary>
            The serialized size if it's already been computed, or null
            if we haven't computed it yet.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractMessage`2.WriteTo(Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Serializes the message and writes it to the given output stream.
            This does not flush or close the stream.
            </summary>
            <remarks>
            Protocol Buffers are not self-delimiting. Therefore, if you write
            any more data to the stream after the message, you must somehow ensure
            that the parser on the receiving end does not interpret this as being
            part of the protocol message. One way of doing this is by writing the size
            of the message before the data, then making sure you limit the input to
            that size when receiving the data. Alternatively, use WriteDelimitedTo(Stream).
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractMessage`2.Equals(System.Object)">
            <summary>
            Compares the specified object with this message for equality.
            Returns true iff the given object is a message of the same type
            (as defined by DescriptorForType) and has identical values
            for all its fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.AbstractMessage`2.GetHashCode">
            <summary>
            Returns the hash code value for this message.
            TODO(jonskeet): Specify the hash algorithm, but better than the Java one!
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.AbstractMessage`2.IsInitialized">
            <summary>
            Returns true iff all required fields in the message and all embedded
            messages are set.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.AbstractMessage`2.SerializedSize">
            <summary>
            Returns the number of bytes required to encode this message.
            The result is only computed on the first call and memoized after that.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ByteArray">
            <summary>
            Provides a utility routine to copy small arrays much more quickly than Buffer.BlockCopy
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.ByteArray.CopyThreshold">
            <summary>
            The threshold above which you should use Buffer.BlockCopy rather than ByteArray.Copy
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteArray.Copy(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Determines which copy routine to use based on the number of bytes to be copied.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteArray.ByteCopy(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy the bytes provided with a for loop, faster when there are only a few bytes to copy
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteArray.Reverse(System.Byte[])">
            <summary>
            Reverses the order of bytes in the array
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ByteString">
            <summary>
            Immutable array of bytes.
            TODO(jonskeet): Implement the common collection interfaces?
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.AttachBytes(System.Byte[])">
            <summary>
            Internal use only.  Ensure that the provided array is not mutated and belongs to this instance.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.#ctor(System.Byte[])">
            <summary>
            Constructs a new ByteString from the given byte array. The array is
            *not* copied, and must not be modified after this constructor is called.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.FromBase64(System.String)">
            <summary>
            Constructs a ByteString from the Base64 Encoded String.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.CopyFrom(System.Byte[])">
            <summary>
            Constructs a ByteString from the given array. The contents
            are copied, so further modifications to the array will not
            be reflected in the returned ByteString.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.CopyFrom(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructs a ByteString from a portion of a byte array.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.CopyFrom(System.String,System.Text.Encoding)">
            <summary>
            Creates a new ByteString by encoding the specified text with
            the given encoding.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.CopyFromUtf8(System.String)">
            <summary>
            Creates a new ByteString by encoding the specified text in UTF-8.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.CreateCodedInput">
            <summary>
            Creates a CodedInputStream from this ByteString's data.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.WriteRawBytesTo(Google.ProtocolBuffers.CodedOutputStream)">
            <summary>
            Used internally by CodedOutputStream to avoid creating a copy for the write
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the entire byte array to the destination array provided at the offset specified.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.WriteTo(System.IO.Stream)">
            <summary>
            Writes the entire byte array to the provided stream
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ByteString.Empty">
            <summary>
            Returns an empty ByteString.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ByteString.Length">
            <summary>
            Returns the length of this ByteString in bytes.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ByteString.Item(System.Int32)">
            <summary>
            Retuns the byte at the given index.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ByteString.Unsafe">
            <summary>
            Unsafe operations that can cause IO Failure and/or other catestrophic side-effects.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.Unsafe.FromBytes(System.Byte[])">
            <summary>
            Constructs a new ByteString from the given byte array. The array is
            *not* copied, and must not be modified after this constructor is called.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ByteString.Unsafe.GetBuffer(Google.ProtocolBuffers.ByteString)">
            <summary>
            Provides direct, unrestricted access to the bytes contained in this instance.
            You must not modify or resize the byte array returned by this method.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ByteString.CodedBuilder">
            <summary>
            Builder for ByteStrings which allows them to be created without extra
            copying being involved. This has to be a nested type in order to have access
            to the private ByteString constructor.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.Enumerables">
            <summary>
            Utility class for IEnumerable (and potentially the generic version in the future).
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.IPopsicleList`1">
            <summary>
            A list which has an Add method which accepts an IEnumerable[T].
            This allows whole collections to be added easily using collection initializers.
            It causes a potential overload confusion if T : IEnumerable[T], but in
            practice that won't happen in protocol buffers.
            </summary>
            <remarks>This is only currently implemented by PopsicleList, and it's likely
            to stay that way - hence the name. More genuinely descriptive names are
            horribly ugly. (At least, the ones the author could think of...)</remarks>
            <typeparam name="T">The element type of the list</typeparam>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.ICastArray">
            <summary>
            Used to efficiently cast the elements of enumerations
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.PopsicleList`1">
            <summary>
            Proxies calls to a <see cref="T:System.Collections.Generic.List`1"/>, but allows the list
            to be made read-only (with the <see cref="M:Google.ProtocolBuffers.Collections.PopsicleList`1.MakeReadOnly"/> method), 
            after which any modifying methods throw <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Collections.PopsicleList`1.MakeReadOnly">
            <summary>
            Makes this list read-only ("freezes the popsicle"). From this
            point on, mutating methods (Clear, Add etc) will throw a
            NotSupportedException. There is no way of "defrosting" the list afterwards.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.CodedOutputStream">
            <summary>
            Encodes and writes protocol message fields.
            </summary>
            <remarks>
            This class contains two kinds of methods:  methods that write specific
            protocol message constructs and field types (e.g. WriteTag and
            WriteInt32) and methods that write low-level values (e.g.
            WriteRawVarint32 and WriteRawBytes).  If you are writing encoded protocol
            messages, you should use the former methods, but if you are writing some
            other format of your own design, use the latter. The names of the former
            methods are taken from the protocol buffer type names, not .NET types.
            (Hence WriteFloat instead of WriteSingle, and WriteBool instead of WriteBoolean.)
            </remarks>
        </member>
        <member name="T:Google.ProtocolBuffers.ICodedOutputStream">
            <summary>
            Provides an interface that is used write a message.  Most often proto buffers are written
            in their binary form by creating a instance via the CodedOutputStream.CreateInstance
            static factory.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteMessageStart">
            <summary>
            Writes any message initialization data needed to the output stream
            </summary>
            <remarks>
            This is primarily used by text formats and unnecessary for protobuffers' own
            binary format.  The API for MessageStart/End was added for consistent handling
            of output streams regardless of the actual writer implementation.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteMessageEnd">
            <summary>
            Writes any message finalization data needed to the output stream
            </summary>
            <remarks>
            This is primarily used by text formats and unnecessary for protobuffers' own
            binary format.  The API for MessageStart/End was added for consistent handling
            of output streams regardless of the actual writer implementation.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.Flush">
            <summary>
            Indicates that all temporary buffers be written to the final output.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteUnknownGroup(System.Int32,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Writes an unknown message as a group
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteUnknownBytes(System.Int32,Google.ProtocolBuffers.ByteString)">
            <summary>
            Writes an unknown field value of bytes
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteUnknownField(System.Int32,Google.ProtocolBuffers.WireFormat.WireType,System.UInt64)">
            <summary>
            Writes an unknown field of a primitive type
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteMessageSetExtension(System.Int32,System.String,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Writes an extension as a message-set group
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteMessageSetExtension(System.Int32,System.String,Google.ProtocolBuffers.ByteString)">
            <summary>
            Writes an unknown extension as a message-set group
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteField(Google.ProtocolBuffers.Descriptors.FieldType,System.Int32,System.String,System.Object)">
            <summary>
            Writes a field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteDouble(System.Int32,System.String,System.Double)">
            <summary>
            Writes a double field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteFloat(System.Int32,System.String,System.Single)">
            <summary>
            Writes a float field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteUInt64(System.Int32,System.String,System.UInt64)">
            <summary>
            Writes a uint64 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteInt64(System.Int32,System.String,System.Int64)">
            <summary>
            Writes an int64 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteInt32(System.Int32,System.String,System.Int32)">
            <summary>
            Writes an int32 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteFixed64(System.Int32,System.String,System.UInt64)">
            <summary>
            Writes a fixed64 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteFixed32(System.Int32,System.String,System.UInt32)">
            <summary>
            Writes a fixed32 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteBool(System.Int32,System.String,System.Boolean)">
            <summary>
            Writes a bool field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteString(System.Int32,System.String,System.String)">
            <summary>
            Writes a string field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteGroup(System.Int32,System.String,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Writes a group field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteMessage(System.Int32,System.String,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Writes a message field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteBytes(System.Int32,System.String,Google.ProtocolBuffers.ByteString)">
            <summary>
            Writes a byte array field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteUInt32(System.Int32,System.String,System.UInt32)">
            <summary>
            Writes a UInt32 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteEnum(System.Int32,System.String,System.Int32,System.Object)">
            <summary>
            Writes an enum field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSFixed32(System.Int32,System.String,System.Int32)">
            <summary>
            Writes a fixed 32-bit field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSFixed64(System.Int32,System.String,System.Int64)">
            <summary>
            Writes a signed fixed 64-bit field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSInt32(System.Int32,System.String,System.Int32)">
            <summary>
            Writes a signed 32-bit field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSInt64(System.Int32,System.String,System.Int64)">
            <summary>
            Writes a signed 64-bit field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteArray(Google.ProtocolBuffers.Descriptors.FieldType,System.Int32,System.String,System.Collections.IEnumerable)">
            <summary>
            Writes a repeated field value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteGroupArray``1(System.Int32,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes a repeated group value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteMessageArray``1(System.Int32,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes a repeated message value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteStringArray(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Writes a repeated string value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteBytesArray(System.Int32,System.String,System.Collections.Generic.IEnumerable{Google.ProtocolBuffers.ByteString})">
            <summary>
            Writes a repeated ByteString value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteBoolArray(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Writes a repeated boolean value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteInt32Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Writes a repeated Int32 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSInt32Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Writes a repeated SInt32 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteUInt32Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Writes a repeated UInt32 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteFixed32Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Writes a repeated Fixed32 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSFixed32Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Writes a repeated SFixed32 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteInt64Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Writes a repeated Int64 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSInt64Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Writes a repeated SInt64 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteUInt64Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
            Writes a repeated UInt64 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteFixed64Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
            Writes a repeated Fixed64 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteSFixed64Array(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Writes a repeated SFixed64 value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteDoubleArray(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Writes a repeated Double value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteFloatArray(System.Int32,System.String,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Writes a repeated Float value, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WriteEnumArray``1(System.Int32,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes a repeated enumeration value of type T, including tag(s), to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedArray(Google.ProtocolBuffers.Descriptors.FieldType,System.Int32,System.String,System.Collections.IEnumerable)">
            <summary>
            Writes a packed repeated primitive, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedBoolArray(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Writes a packed repeated boolean, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedInt32Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Writes a packed repeated Int32, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedSInt32Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Writes a packed repeated SInt32, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedUInt32Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Writes a packed repeated UInt32, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedFixed32Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Writes a packed repeated Fixed32, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedSFixed32Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Writes a packed repeated SFixed32, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedInt64Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Writes a packed repeated Int64, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedSInt64Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Writes a packed repeated SInt64, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedUInt64Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
            Writes a packed repeated UInt64, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedFixed64Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
            Writes a packed repeated Fixed64, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedSFixed64Array(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Writes a packed repeated SFixed64, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedDoubleArray(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Writes a packed repeated Double, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedFloatArray(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Writes a packed repeated Float, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedOutputStream.WritePackedEnumArray``1(System.Int32,System.String,System.Int32,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes a packed repeated enumeration of type T, including tag and length, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeDoubleSize(System.Int32,System.Double)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            double field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFloatSize(System.Int32,System.Single)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            float field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeUInt64Size(System.Int32,System.UInt64)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            uint64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeInt64Size(System.Int32,System.Int64)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            int64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeInt32Size(System.Int32,System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            int32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFixed64Size(System.Int32,System.UInt64)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            fixed64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFixed32Size(System.Int32,System.UInt32)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            fixed32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeBoolSize(System.Int32,System.Boolean)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            bool field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeStringSize(System.Int32,System.String)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            string field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeGroupSize(System.Int32,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            group field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeUnknownGroupSize(System.Int32,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            group field represented by an UnknownFieldSet, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeMessageSize(System.Int32,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            embedded message field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeBytesSize(System.Int32,Google.ProtocolBuffers.ByteString)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            bytes field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeUInt32Size(System.Int32,System.UInt32)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            uint32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeEnumSize(System.Int32,System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            enum field, including the tag. The caller is responsible for
            converting the enum value to its numeric value.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSFixed32Size(System.Int32,System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sfixed32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSFixed64Size(System.Int32,System.Int64)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sfixed64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSInt32Size(System.Int32,System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sint32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSInt64Size(System.Int32,System.Int64)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sint64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeDoubleSizeNoTag(System.Double)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            double field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFloatSizeNoTag(System.Single)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            float field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeUInt64SizeNoTag(System.UInt64)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            uint64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeInt64SizeNoTag(System.Int64)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            int64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeInt32SizeNoTag(System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            int32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFixed64SizeNoTag(System.UInt64)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            fixed64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFixed32SizeNoTag(System.UInt32)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            fixed32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeBoolSizeNoTag(System.Boolean)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            bool field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeStringSizeNoTag(System.String)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            string field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeGroupSizeNoTag(Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            group field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeUnknownGroupSizeNoTag(Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            group field represented by an UnknownFieldSet, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeMessageSizeNoTag(Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            embedded message field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeBytesSizeNoTag(Google.ProtocolBuffers.ByteString)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            bytes field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeUInt32SizeNoTag(System.UInt32)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            uint32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeEnumSizeNoTag(System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            enum field, including the tag. The caller is responsible for
            converting the enum value to its numeric value.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSFixed32SizeNoTag(System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sfixed32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSFixed64SizeNoTag(System.Int64)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sfixed64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSInt32SizeNoTag(System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sint32 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeSInt64SizeNoTag(System.Int64)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            sint64 field, including the tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeMessageSetExtensionSize(System.Int32,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            MessageSet extension to the stream. For historical reasons,
            the wire format differs from normal fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeRawMessageSetExtensionSize(System.Int32,Google.ProtocolBuffers.ByteString)">
            <summary>
            Compute the number of bytes that would be needed to encode an
            unparsed MessageSet extension field to the stream. For
            historical reasons, the wire format differs from normal fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeRawVarint32Size(System.UInt32)">
            <summary>
            Compute the number of bytes that would be needed to encode a varint.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeRawVarint64Size(System.UInt64)">
            <summary>
            Compute the number of bytes that would be needed to encode a varint.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFieldSize(Google.ProtocolBuffers.Descriptors.FieldType,System.Int32,System.Object)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            field of arbitrary type, including the tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeFieldSizeNoTag(Google.ProtocolBuffers.Descriptors.FieldType,System.Object)">
            <summary>
            Compute the number of bytes that would be needed to encode a
            field of arbitrary type, excluding the tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.ComputeTagSize(System.Int32)">
            <summary>
            Compute the number of bytes that would be needed to encode a tag.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.CodedOutputStream.DefaultBufferSize">
            <summary>
            The buffer size used by CreateInstance(Stream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.CreateInstance(System.IO.Stream)">
            <summary>
            Creates a new CodedOutputStream which write to the given stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.CreateInstance(System.IO.Stream,System.Int32)">
            <summary>
            Creates a new CodedOutputStream which write to the given stream and uses
            the specified buffer size.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.CreateInstance(System.Byte[])">
            <summary>
            Creates a new CodedOutputStream that writes directly to the given
            byte array. If more bytes are written than fit in the array,
            OutOfSpaceException will be thrown.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.CreateInstance(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new CodedOutputStream that writes directly to the given
            byte array slice. If more bytes are written than fit in the array,
            OutOfSpaceException will be thrown.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteDouble(System.Int32,System.String,System.Double)">
            <summary>
            Writes a double field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteFloat(System.Int32,System.String,System.Single)">
            <summary>
            Writes a float field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteUInt64(System.Int32,System.String,System.UInt64)">
            <summary>
            Writes a uint64 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteInt64(System.Int32,System.String,System.Int64)">
            <summary>
            Writes an int64 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteInt32(System.Int32,System.String,System.Int32)">
            <summary>
            Writes an int32 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteFixed64(System.Int32,System.String,System.UInt64)">
            <summary>
            Writes a fixed64 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteFixed32(System.Int32,System.String,System.UInt32)">
            <summary>
            Writes a fixed32 field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteBool(System.Int32,System.String,System.Boolean)">
            <summary>
            Writes a bool field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteString(System.Int32,System.String,System.String)">
            <summary>
            Writes a string field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteGroup(System.Int32,System.String,Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Writes a group field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteDoubleNoTag(System.Double)">
            <summary>
            Writes a double field value, including tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteFloatNoTag(System.Single)">
            <summary>
            Writes a float field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteUInt64NoTag(System.UInt64)">
            <summary>
            Writes a uint64 field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteInt64NoTag(System.Int64)">
            <summary>
            Writes an int64 field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteInt32NoTag(System.Int32)">
            <summary>
            Writes an int32 field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteFixed64NoTag(System.UInt64)">
            <summary>
            Writes a fixed64 field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteFixed32NoTag(System.UInt32)">
            <summary>
            Writes a fixed32 field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteBoolNoTag(System.Boolean)">
            <summary>
            Writes a bool field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteStringNoTag(System.String)">
            <summary>
            Writes a string field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteGroupNoTag(Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Writes a group field value, without a tag, to the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteTag(System.Int32,Google.ProtocolBuffers.WireFormat.WireType)">
            <summary>
            Encodes and writes a tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteRawVarint32(System.UInt32)">
            <summary>
            Writes a 32 bit value as a varint. The fast route is taken when
            there's enough buffer space left to whizz through without checking
            for each byte; otherwise, we resort to calling WriteRawByte each time.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteRawBytes(System.Byte[])">
            <summary>
            Writes out an array of bytes.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.WriteRawBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes out part of an array of bytes.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.EncodeZigZag32(System.Int32)">
            <summary>
            Encode a 32-bit value with ZigZag encoding.
            </summary>
            <remarks>
            ZigZag encodes signed integers into values that can be efficiently
            encoded with varint.  (Otherwise, negative values must be 
            sign-extended to 64 bits to be varint encoded, thus always taking
            10 bytes on the wire.)
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.EncodeZigZag64(System.Int64)">
            <summary>
            Encode a 64-bit value with ZigZag encoding.
            </summary>
            <remarks>
            ZigZag encodes signed integers into values that can be efficiently
            encoded with varint.  (Otherwise, negative values must be 
            sign-extended to 64 bits to be varint encoded, thus always taking
            10 bytes on the wire.)
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedOutputStream.CheckNoSpaceLeft">
            <summary>
            Verifies that SpaceLeft returns zero. It's common to create a byte array
            that is exactly big enough to hold a message, then write to it with
            a CodedOutputStream. Calling CheckNoSpaceLeft after writing verifies that
            the message was actually as big as expected, which can help bugs.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.CodedOutputStream.Position">
            <summary>
            Returns the current position in the stream, or the position in the output buffer
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.CodedOutputStream.SpaceLeft">
            <summary>
            If writing to a flat array, returns the space left in the array. Otherwise,
            throws an InvalidOperationException.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.CodedOutputStream.OutOfSpaceException">
            <summary>
            Indicates that a CodedOutputStream wrapping a flat byte array
            ran out of space.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.GeneratedMessageLite`2">
            <summary>
            All generated protocol message classes extend this class. It implements
            most of the IMessage interface using reflection. Users
            can ignore this class as an implementation detail.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedMessageLite`2.PrintField``1(System.String,System.Collections.Generic.IList{``0},System.IO.TextWriter)">
            <summary>
            PrintTo() helper methods for Lite Runtime
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedMessageLite`2.PrintField(System.String,System.Boolean,System.Object,System.IO.TextWriter)">
            <summary>
            PrintTo() helper methods for Lite Runtime
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedMessageLite`2.EscapeBytes(System.Collections.Generic.IEnumerable{System.Byte},System.IO.TextWriter)">
            <summary>
            COPIED from TextFormat
            Escapes bytes in the format used in protocol buffer text format, which
            is the same as the format used for C string literals.  All bytes
            that are not printable 7-bit ASCII characters are escaped, as well as
            backslash, single-quote, and double-quote characters.  Characters for
            which no defined short-hand escape sequence is defined will be escaped
            using 3-digit octal sequences.
            The returned value is guaranteed to be entirely ASCII.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessageLite`2.PrintTo(System.IO.TextWriter)">
            <summary>
            writes the extensions to the text stream
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessageLite`2.HasExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,``0})">
            <summary>
            Checks if a singular extension is present.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessageLite`2.GetExtensionCount``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,System.Collections.Generic.IList{``0}})">
            <summary>
            Returns the number of elements in a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessageLite`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,``0})">
            <summary>
            Returns the value of an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessageLite`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,System.Collections.Generic.IList{``0}},System.Int32)">
            <summary>
            Returns one element of a repeated extension.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtendableMessageLite`2.Extensions">
            <summary>
            Access for the builder.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtendableMessageLite`2.ExtensionsAreInitialized">
            <summary>
            Called to check if all extensions are initialized.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtendableMessageLite`2.ExtensionsSerializedSize">
            <summary>
            Called by subclasses to compute the size of extensions.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ExtendableMessageLite`2.ExtensionWriter">
            <summary>
            Used by subclasses to serialize extensions. Extension ranges may be
            interleaves with field numbers, but we must write them in canonical
            (sorted by field number) order. This class helps us to write individual
            ranges of extensions at once.
            
            TODO(jonskeet): See if we can improve this in terms of readability.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.GeneratedMessage`2">
            <summary>
            All generated protocol message classes extend this class. It implements
            most of the IMessage interface using reflection. Users
            can ignore this class as an implementation detail.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedMessage`2.SetUnknownFields(Google.ProtocolBuffers.UnknownFieldSet)">
            <summary>
            Replaces the set of unknown fields for this message. This should
            only be used before a message is built, by the builder. (In the
            Java code it is private, but the builder is nested so has access
            to it.)
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedMessage`2.ThisMessage">
            <summary>
            Returns the message as a TMessage.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessage`2.HasExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{``0})">
            <summary>
            Checks if a singular extension is present.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessage`2.GetExtensionCount``1(Google.ProtocolBuffers.GeneratedExtensionBase{System.Collections.Generic.IList{``0}})">
            <summary>
            Returns the number of elements in a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessage`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{``0})">
            <summary>
            Returns the value of an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableMessage`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{System.Collections.Generic.IList{``0}},System.Int32)">
            <summary>
            Returns one element of a repeated extension.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtendableMessage`2.Extensions">
            <summary>
            Access for the builder.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtendableMessage`2.ExtensionsAreInitialized">
            <summary>
            Called to check if all extensions are initialized.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtendableMessage`2.ExtensionsSerializedSize">
            <summary>
            Called by subclasses to compute the size of extensions.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ExtendableMessage`2.ExtensionWriter">
            <summary>
            Used by subclasses to serialize extensions. Extension ranges may be
            interleaves with field numbers, but we must write them in canonical
            (sorted by field number) order. This class helps us to write individual
            ranges of extensions at once.
            
            TODO(jonskeet): See if we can improve this in terms of readability.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.GeneratedBuilderLite`2">
            <summary>
            All generated protocol message builder classes extend this class. It implements
            most of the IBuilder interface using reflection. Users can ignore this class
            as an implementation detail.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedBuilderLite`2.ParseUnknownField(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry,System.UInt32,System.String)">
            <summary>
            Called by derived classes to parse an unknown field.
            </summary>
            <returns>true unless the tag is an end-group tag</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedBuilderLite`2.BuildParsed">
            <summary>
            Like Build(), but will wrap UninitializedMessageException in
            InvalidProtocolBufferException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedBuilderLite`2.Build">
            <summary>
            Implementation of <see cref="M:Google.ProtocolBuffers.IBuilder`2.Build"/>.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedBuilderLite`2.MessageBeingBuilt">
            <summary>
            Returns the message being built at the moment.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.HasExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,``0})">
            <summary>
            Checks if a singular extension is present
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.GetExtensionCount``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,System.Collections.Generic.IList{``0}})">
            <summary>
            Returns the number of elements in a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,``0})">
            <summary>
            Returns the value of an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,System.Collections.Generic.IList{``0}},System.Int32)">
            <summary>
            Returns one element of a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.SetExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,``0},``0)">
            <summary>
            Sets the value of an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.SetExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,System.Collections.Generic.IList{``0}},System.Int32,``0)">
            <summary>
            Sets the value of one element of a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.AddExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,System.Collections.Generic.IList{``0}},``0)">
            <summary>
            Appends a value to a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.ClearExtension``1(Google.ProtocolBuffers.GeneratedExtensionLite{`0,``0})">
            <summary>
            Clears an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilderLite`2.ParseUnknownField(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry,System.UInt32,System.String)">
            <summary>
            Called by subclasses to parse an unknown field or an extension.
            </summary>
            <returns>true unless the tag is an end-group tag</returns>
        </member>
        <member name="T:Google.ProtocolBuffers.GeneratedBuilder`2">
            <summary>
            All generated protocol message builder classes extend this class. It implements
            most of the IBuilder interface using reflection. Users can ignore this class
            as an implementation detail.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedBuilder`2.ParseUnknownField(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.UnknownFieldSet.Builder,Google.ProtocolBuffers.ExtensionRegistry,System.UInt32,System.String)">
            <summary>
            Called by derived classes to parse an unknown field.
            </summary>
            <returns>true unless the tag is an end-group tag</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedBuilder`2.BuildParsed">
            <summary>
            Like Build(), but will wrap UninitializedMessageException in
            InvalidProtocolBufferException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedBuilder`2.Build">
            <summary>
            Implementation of <see cref="M:Google.ProtocolBuffers.IBuilder`2.Build"/>.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedBuilder`2.MessageBeingBuilt">
            <summary>
            Returns the message being built at the moment.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.HasExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{``0})">
            <summary>
            Checks if a singular extension is present
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.GetExtensionCount``1(Google.ProtocolBuffers.GeneratedExtensionBase{System.Collections.Generic.IList{``0}})">
            <summary>
            Returns the number of elements in a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{``0})">
            <summary>
            Returns the value of an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.GetExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{System.Collections.Generic.IList{``0}},System.Int32)">
            <summary>
            Returns one element of a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.SetExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{``0},``0)">
            <summary>
            Sets the value of an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.SetExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{System.Collections.Generic.IList{``0}},System.Int32,``0)">
            <summary>
            Sets the value of one element of a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.AddExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{System.Collections.Generic.IList{``0}},``0)">
            <summary>
            Appends a value to a repeated extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.ClearExtension``1(Google.ProtocolBuffers.GeneratedExtensionBase{``0})">
            <summary>
            Clears an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtendableBuilder`2.ParseUnknownField(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.UnknownFieldSet.Builder,Google.ProtocolBuffers.ExtensionRegistry,System.UInt32,System.String)">
            <summary>
            Called by subclasses to parse an unknown field or an extension.
            </summary>
            <returns>true unless the tag is an end-group tag</returns>
        </member>
        <member name="T:Google.ProtocolBuffers.DynamicMessage">
            <summary>
            An implementation of IMessage that can represent arbitrary types, given a MessageaDescriptor.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.#ctor(Google.ProtocolBuffers.Descriptors.MessageDescriptor,Google.ProtocolBuffers.FieldSet,Google.ProtocolBuffers.UnknownFieldSet)">
            <summary>
            Creates a DynamicMessage with the given FieldSet.
            </summary>
            <param name="type"></param>
            <param name="fields"></param>
            <param name="unknownFields"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.GetDefaultInstance(Google.ProtocolBuffers.Descriptors.MessageDescriptor)">
            <summary>
            Returns a DynamicMessage representing the default instance of the given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,Google.ProtocolBuffers.ICodedInputStream)">
            <summary>
            Parses a message of the given type from the given stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse a message of the given type from the given stream and extension registry.
            </summary>
            <param name="type"></param>
            <param name="input"></param>
            <param name="extensionRegistry"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,System.IO.Stream)">
            <summary>
            Parses a message of the given type from the given stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,System.IO.Stream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse a message of the given type from the given stream and extension registry.
            </summary>
            <param name="type"></param>
            <param name="input"></param>
            <param name="extensionRegistry"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,Google.ProtocolBuffers.ByteString)">
            <summary>
            Parse <paramref name="data"/> as a message of the given type and return it.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,Google.ProtocolBuffers.ByteString,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="data"/> as a message of the given type and return it.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,System.Byte[])">
            <summary>
            Parse <paramref name="data"/> as a message of the given type and return it.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.ParseFrom(Google.ProtocolBuffers.Descriptors.MessageDescriptor,System.Byte[],Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Parse <paramref name="data"/> as a message of the given type and return it.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.CreateBuilder(Google.ProtocolBuffers.Descriptors.MessageDescriptor)">
            <summary>
            Constructs a builder for the given type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.CreateBuilder(Google.ProtocolBuffers.IMessage)">
            <summary>
            Constructs a builder for a message of the same type as <paramref name="prototype"/>,
            and initializes it with the same contents.
            </summary>
            <param name="prototype"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.VerifyContainingType(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Verifies that the field is a field of this message.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.DynamicMessage.Builder">
            <summary>
            Builder for dynamic messages. Instances are created with DynamicMessage.CreateBuilder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.Builder.BuildParsed">
            <summary>
            Helper for DynamicMessage.ParseFrom() methods to call. Throws
            InvalidProtocolBufferException 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.DynamicMessage.Builder.VerifyContainingType(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Verifies that the field is a field of this message.
            </summary>
            <param name="field"></param>
        </member>
        <member name="T:Google.ProtocolBuffers.StreamProvider">
            <summary>
            Delegate to return a stream when asked, used by MessageStreamIterator.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.CodedInputStream">
            <summary>
            Readings and decodes protocol message fields.
            </summary>
            <remarks>
            This class contains two kinds of methods:  methods that read specific
            protocol message constructs and field types (e.g. ReadTag and
            ReadInt32) and methods that read low-level values (e.g.
            ReadRawVarint32 and ReadRawBytes).  If you are reading encoded protocol
            messages, you should use the former methods, but if you are reading some
            other format of your own design, use the latter. The names of the former
            methods are taken from the protocol buffer type names, not .NET types.
            (Hence ReadFloat instead of ReadSingle, and ReadBool instead of ReadBoolean.)
            
            TODO(jonskeet): Consider whether recursion and size limits shouldn't be readonly,
            set at construction time.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadMessageStart">
            <summary>
            Reads any message initialization data expected from the input stream
            </summary>
            <remarks>
            This is primarily used by text formats and unnecessary for protobuffers' own
            binary format.  The API for MessageStart/End was added for consistent handling
            of output streams regardless of the actual writer implementation.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadMessageEnd">
            <summary>
            Reads any message finalization data expected from the input stream
            </summary>
            <remarks>
            This is primarily used by text formats and unnecessary for protobuffers' own
            binary format.  The API for MessageStart/End was added for consistent handling
            of output streams regardless of the actual writer implementation.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadTag(System.UInt32@,System.String@)">
            <summary>
            Attempt to read a field tag, returning false if we have reached the end
            of the input data.
            </summary>
            <remarks>
            <para>
            If fieldTag is non-zero and ReadTag returns true then the value in fieldName
            may or may not be populated.  However, if fieldTag is zero and ReadTag returns
            true, then fieldName should be populated with a non-null field name.
            </para><para>
            In other words if ReadTag returns true then either fieldTag will be non-zero OR
            fieldName will be non-zero.  In some cases both may be populated, however the
            builders will always prefer the fieldTag over fieldName.
            </para>
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadDouble(System.Double@)">
            <summary>
            Read a double field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadFloat(System.Single@)">
            <summary>
            Read a float field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadUInt64(System.UInt64@)">
            <summary>
            Read a uint64 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadInt64(System.Int64@)">
            <summary>
            Read an int64 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadInt32(System.Int32@)">
            <summary>
            Read an int32 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadFixed64(System.UInt64@)">
            <summary>
            Read a fixed64 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadFixed32(System.UInt32@)">
            <summary>
            Read a fixed32 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadBool(System.Boolean@)">
            <summary>
            Read a bool field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadString(System.String@)">
            <summary>
            Reads a string field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadGroup(System.Int32,Google.ProtocolBuffers.IBuilderLite,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Reads a group field value from the stream.
            </summary>    
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadUnknownGroup(System.Int32,Google.ProtocolBuffers.IBuilderLite)">
            <summary>
            Reads a group field value from the stream and merges it into the given
            UnknownFieldSet.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadMessage(Google.ProtocolBuffers.IBuilderLite,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Reads an embedded message field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadBytes(Google.ProtocolBuffers.ByteString@)">
            <summary>
            Reads a bytes field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadUInt32(System.UInt32@)">
            <summary>
            Reads a uint32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadEnum(Google.ProtocolBuffers.IEnumLite@,System.Object@,Google.ProtocolBuffers.IEnumLiteMap)">
            <summary>
            Reads an enum field value from the stream. The caller is responsible
            for converting the numeric value to an actual enum.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadEnum``1(``0@,System.Object@)">
            <summary>
            Reads an enum field value from the stream. If the enum is valid for type T,
            then the ref value is set and it returns true.  Otherwise the unkown output
            value is set and this method returns false.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSFixed32(System.Int32@)">
            <summary>
            Reads an sfixed32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSFixed64(System.Int64@)">
            <summary>
            Reads an sfixed64 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSInt32(System.Int32@)">
            <summary>
            Reads an sint32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSInt64(System.Int64@)">
            <summary>
            Reads an sint64 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadPrimitiveArray(Google.ProtocolBuffers.Descriptors.FieldType,System.UInt32,System.String,System.Collections.Generic.ICollection{System.Object})">
            <summary>
            Reads an array of primitive values into the list, if the wire-type of fieldTag is length-prefixed and the 
            type is numeric, it will read a packed array.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadEnumArray(System.UInt32,System.String,System.Collections.Generic.ICollection{Google.ProtocolBuffers.IEnumLite},System.Collections.Generic.ICollection{System.Object}@,Google.ProtocolBuffers.IEnumLiteMap)">
            <summary>
            Reads an array of primitive values into the list, if the wire-type of fieldTag is length-prefixed, it will
            read a packed array.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadEnumArray``1(System.UInt32,System.String,System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{System.Object}@)">
            <summary>
            Reads an array of primitive values into the list, if the wire-type of fieldTag is length-prefixed, it will
            read a packed array.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadMessageArray``1(System.UInt32,System.String,System.Collections.Generic.ICollection{``0},``0,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Reads a set of messages using the <paramref name="messageType"/> as a template.  T is not guaranteed to be 
            the most derived type, it is only the type specifier for the collection.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadGroupArray``1(System.UInt32,System.String,System.Collections.Generic.ICollection{``0},``0,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Reads a set of messages using the <paramref name="messageType"/> as a template.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadPrimitiveField(Google.ProtocolBuffers.Descriptors.FieldType,System.Object@)">
            <summary>
            Reads a field of any primitive type. Enums, groups and embedded
            messages are not handled by this method.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.SkipField">
            <summary>
            Reads and discards a single field, given its tag value.
            </summary>
            <returns>false if the tag is an end-group tag, in which case
            nothing is skipped. Otherwise, returns true.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadStringArray(System.UInt32,System.String,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Reads one or more repeated string field values from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadBytesArray(System.UInt32,System.String,System.Collections.Generic.ICollection{Google.ProtocolBuffers.ByteString})">
            <summary>
            Reads one or more repeated ByteString field values from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadBoolArray(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Boolean})">
            <summary>
            Reads one or more repeated boolean field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadInt32Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Reads one or more repeated Int32 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSInt32Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Reads one or more repeated SInt32 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadUInt32Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.UInt32})">
            <summary>
            Reads one or more repeated UInt32 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadFixed32Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.UInt32})">
            <summary>
            Reads one or more repeated Fixed32 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSFixed32Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Reads one or more repeated SFixed32 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadInt64Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Int64})">
            <summary>
            Reads one or more repeated Int64 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSInt64Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Int64})">
            <summary>
            Reads one or more repeated SInt64 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadUInt64Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.UInt64})">
            <summary>
            Reads one or more repeated UInt64 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadFixed64Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.UInt64})">
            <summary>
            Reads one or more repeated Fixed64 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadSFixed64Array(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Int64})">
            <summary>
            Reads one or more repeated SFixed64 field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadDoubleArray(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Double})">
            <summary>
            Reads one or more repeated Double field values from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ICodedInputStream.ReadFloatArray(System.UInt32,System.String,System.Collections.Generic.ICollection{System.Single})">
            <summary>
            Reads one or more repeated Float field values from the stream.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ICodedInputStream.IsAtEnd">
            <summary>
            Returns true if the stream has reached the end of the input. This is the
            case if either the end of the underlying input source has been reached or
            the stream has reached a limit created using PushLimit.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.CodedInputStream.totalBytesRetired">
            <summary>
            The total number of bytes read before the current buffer. The
            total bytes read up to the current position can be computed as
            totalBytesRetired + bufferPos.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.CodedInputStream.currentLimit">
            <summary>
            The absolute position of the end of the current message.
            </summary> 
        </member>
        <member name="F:Google.ProtocolBuffers.CodedInputStream.recursionDepth">
            <summary>
            <see cref="M:Google.ProtocolBuffers.CodedInputStream.SetRecursionLimit(System.Int32)"/>
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.CodedInputStream.sizeLimit">
            <summary>
            <see cref="M:Google.ProtocolBuffers.CodedInputStream.SetSizeLimit(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.CreateInstance(System.IO.Stream)">
            <summary>
            Creates a new CodedInputStream reading data from the given
            stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.CreateInstance(System.IO.Stream,System.Byte[])">
            <summary>
            Creates a new CodedInputStream reading data from the given
            stream and a pre-allocated memory buffer.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.CreateInstance(System.Byte[])">
            <summary>
            Creates a new CodedInputStream reading data from the given
            byte array.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.CreateInstance(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new CodedInputStream that reads from the given
            byte array slice.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.CheckLastTagWas(System.UInt32)">
            <summary>
            Verifies that the last call to ReadTag() returned the given tag value.
            This is used to verify that a nested group ended with the correct
            end tag.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.InvalidProtocolBufferException">The last
            tag read was not the one specified</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.PeekNextTag(System.UInt32@,System.String@)">
            <summary>
            Attempt to peek at the next field tag.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadTag(System.UInt32@,System.String@)">
            <summary>
            Attempt to read a field tag, returning false if we have reached the end
            of the input data.
            </summary>
            <param name="fieldTag">The 'tag' of the field (id * 8 + wire-format)</param>
            <param name="fieldName">Not Supported - For protobuffer streams, this parameter is always null</param>
            <returns>true if the next fieldTag was read</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadDouble(System.Double@)">
            <summary>
            Read a double field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadFloat(System.Single@)">
            <summary>
            Read a float field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadUInt64(System.UInt64@)">
            <summary>
            Read a uint64 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadInt64(System.Int64@)">
            <summary>
            Read an int64 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadInt32(System.Int32@)">
            <summary>
            Read an int32 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadFixed64(System.UInt64@)">
            <summary>
            Read a fixed64 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadFixed32(System.UInt32@)">
            <summary>
            Read a fixed32 field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadBool(System.Boolean@)">
            <summary>
            Read a bool field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadString(System.String@)">
            <summary>
            Reads a string field from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadGroup(System.Int32,Google.ProtocolBuffers.IBuilderLite,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Reads a group field value from the stream.
            </summary>    
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadUnknownGroup(System.Int32,Google.ProtocolBuffers.IBuilderLite)">
            <summary>
            Reads a group field value from the stream and merges it into the given
            UnknownFieldSet.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadMessage(Google.ProtocolBuffers.IBuilderLite,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Reads an embedded message field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadBytes(Google.ProtocolBuffers.ByteString@)">
            <summary>
            Reads a bytes field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadUInt32(System.UInt32@)">
            <summary>
            Reads a uint32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadEnum(Google.ProtocolBuffers.IEnumLite@,System.Object@,Google.ProtocolBuffers.IEnumLiteMap)">
            <summary>
            Reads an enum field value from the stream. The caller is responsible
            for converting the numeric value to an actual enum.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadEnum``1(``0@,System.Object@)">
            <summary>
            Reads an enum field value from the stream. If the enum is valid for type T,
            then the ref value is set and it returns true.  Otherwise the unknown output
            value is set and this method returns false.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadSFixed32(System.Int32@)">
            <summary>
            Reads an sfixed32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadSFixed64(System.Int64@)">
            <summary>
            Reads an sfixed64 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadSInt32(System.Int32@)">
            <summary>
            Reads an sint32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadSInt64(System.Int64@)">
            <summary>
            Reads an sint64 field value from the stream.
            </summary>   
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ContinueArray(System.UInt32)">
            <summary>
            Returns true if the next tag is also part of the same unpacked array.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ContinueArray(System.UInt32,System.Boolean,System.Int32)">
            <summary>
            Returns true if the next tag is also part of the same array, which may or may not be packed.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadPrimitiveField(Google.ProtocolBuffers.Descriptors.FieldType,System.Object@)">
            <summary>
            Reads a field of any primitive type. Enums, groups and embedded
            messages are not handled by this method.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.SlowReadRawVarint32">
            <summary>
            Same code as ReadRawVarint32, but read each byte individually, checking for
            buffer overflow.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadRawVarint32">
            <summary>
            Read a raw Varint from the stream.  If larger than 32 bits, discard the upper bits.
            This method is optimised for the case where we've got lots of data in the buffer.
            That means we can check the size just once, then just read directly from the buffer
            without constant rechecking of the buffer length.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadRawVarint32(System.IO.Stream)">
            <summary>
            Reads a varint from the input one byte at a time, so that it does not
            read any bytes after the end of the varint. If you simply wrapped the
            stream in a CodedInputStream and used ReadRawVarint32(Stream)}
            then you would probably end up reading past the end of the varint since
            CodedInputStream buffers its input.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadRawVarint64">
            <summary>
            Read a raw varint from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadRawLittleEndian32">
            <summary>
            Read a 32-bit little-endian integer from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadRawLittleEndian64">
            <summary>
            Read a 64-bit little-endian integer from the stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.DecodeZigZag32(System.UInt32)">
            <summary>
            Decode a 32-bit value with ZigZag encoding.
            </summary>
            <remarks>
            ZigZag encodes signed integers into values that can be efficiently
            encoded with varint.  (Otherwise, negative values must be 
            sign-extended to 64 bits to be varint encoded, thus always taking
            10 bytes on the wire.)
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.DecodeZigZag64(System.UInt64)">
            <summary>
            Decode a 32-bit value with ZigZag encoding.
            </summary>
            <remarks>
            ZigZag encodes signed integers into values that can be efficiently
            encoded with varint.  (Otherwise, negative values must be 
            sign-extended to 64 bits to be varint encoded, thus always taking
            10 bytes on the wire.)
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.SetRecursionLimit(System.Int32)">
            <summary>
            Set the maximum message recursion depth.
            </summary>
            <remarks>
            In order to prevent malicious
            messages from causing stack overflows, CodedInputStream limits
            how deeply messages may be nested.  The default limit is 64.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.SetSizeLimit(System.Int32)">
            <summary>
            Set the maximum message size.
            </summary>
            <remarks>
            In order to prevent malicious messages from exhausting memory or
            causing integer overflows, CodedInputStream limits how large a message may be.
            The default limit is 64MB.  You should set this limit as small
            as you can without harming your app's functionality.  Note that
            size limits only apply when reading from an InputStream, not
            when constructed around a raw byte array (nor with ByteString.NewCodedInput).
            If you want to read several messages from a single CodedInputStream, you
            can call ResetSizeCounter() after each message to avoid hitting the
            size limit.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ResetSizeCounter">
            <summary>
            Resets the current size counter to zero (see SetSizeLimit).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.PushLimit(System.Int32)">
            <summary>
            Sets currentLimit to (current position) + byteLimit. This is called
            when descending into a length-delimited embedded message. The previous
            limit is returned.
            </summary>
            <returns>The old limit.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.PopLimit(System.Int32)">
            <summary>
            Discards the current limit, returning the previous limit.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.RefillBuffer(System.Boolean)">
            <summary>
            Called when buffer is empty to read more bytes from the
            input.  If <paramref name="mustSucceed"/> is true, RefillBuffer() gurantees that
            either there will be at least one byte in the buffer when it returns
            or it will throw an exception.  If <paramref name="mustSucceed"/> is false,
            RefillBuffer() returns false if no more bytes were available.
            </summary>
            <param name="mustSucceed"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadRawByte">
            <summary>
            Read one byte from the input.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.InvalidProtocolBufferException">
            the end of the stream or the current limit was reached
            </exception>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.ReadRawBytes(System.Int32)">
            <summary>
            Read a fixed size of bytes from the input.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.InvalidProtocolBufferException">
            the end of the stream or the current limit was reached
            </exception>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.SkipField">
            <summary>
            Reads and discards a single field, given its tag value.
            </summary>
            <returns>false if the tag is an end-group tag, in which case
            nothing is skipped. Otherwise, returns true.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.SkipMessage">
            <summary>
            Reads and discards an entire message.  This will read either until EOF
            or until an endgroup tag, whichever comes first.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.SkipRawBytes(System.Int32)">
            <summary>
            Reads and discards <paramref name="size"/> bytes.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.InvalidProtocolBufferException">the end of the stream
            or the current limit was reached</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.CodedInputStream.SkipImpl(System.Int32)">
            <summary>
            Abstraction of skipping to cope with streams which can't really skip.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.CodedInputStream.Position">
            <summary>
            Returns the current position in the input stream, or the position in the input buffer
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.CodedInputStream.ReachedLimit">
            <summary>
            Returns whether or not all the data before the limit has been read.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Google.ProtocolBuffers.CodedInputStream.IsAtEnd">
            <summary>
            Returns true if the stream has reached the end of the input. This is the
            case if either the end of the underlying input source has been reached or
            the stream has reached a limit created using PushLimit.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.Dictionaries">
            <summary>
            Utility class for dictionaries.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Collections.Dictionaries.Equals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Compares two dictionaries for equality. Each value is compared with equality using Equals
            for non-IEnumerable implementations, and using EnumerableEquals otherwise.
            TODO(jonskeet): This is clearly pretty slow, and involves lots of boxing/unboxing...
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Collections.Dictionaries.GetHashCode``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Creates a hashcode for a dictionary by XORing the hashcodes of all the fields
            and values. (By XORing, we avoid ordering issues.)
            TODO(jonskeet): Currently XORs other stuff too, and assumes non-null values.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Collections.Dictionaries.GetDeepHashCode(System.Object)">
            <summary>
            Determines the hash of a value by either taking it directly or hashing all the elements
            for IEnumerable implementations.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.Lists">
            <summary>
            Utility non-generic class for calling into Lists{T} using type inference.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Collections.Lists.AsReadOnly``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a read-only view of the specified list.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.Lists`1">
            <summary>
            Utility class for dealing with lists.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Collections.Lists`1.AsReadOnly(System.Collections.Generic.IList{`0})">
            <summary>
            Returns either the original reference if it's already read-only,
            or a new ReadOnlyCollection wrapping the original list.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Collections.Lists`1.Empty">
            <summary>
            Returns an immutable empty list.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Collections.ReadOnlyDictionary`2">
            <summary>
            Read-only wrapper around another dictionary.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.DescriptorProtos.IDescriptorProto`1">
            <summary>
            Interface implemented by all DescriptorProtos. The generator doesn't
            emit the interface implementation claim, so PartialClasses.cs contains
            partial class declarations for each of them.
            </summary>
            <typeparam name="TOptions">The associated options protocol buffer type</typeparam>
        </member>
        <member name="P:Google.ProtocolBuffers.DescriptorProtos.IDescriptorProto`1.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.DescriptorProtos.IDescriptorProto`1.Options">
            <summary>
            The options for this descriptor.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.DescriptorBase`2">
            <summary>
            Base class for nearly all descriptors, providing common functionality.
            </summary>
            <typeparam name="TProto">Type of the protocol buffer form of this descriptor</typeparam>
            <typeparam name="TOptions">Type of the options protocol buffer for this descriptor</typeparam>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.IDescriptor`1">
            <summary>
            Strongly-typed form of the IDescriptor interface.
            </summary>
            <typeparam name="TProto">Protocol buffer type underlying this descriptor type</typeparam>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.IDescriptor">
            <summary>
            The non-generic form of the IDescriptor interface. Useful for describing a general
            descriptor.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.DescriptorBase`2.Proto">
            <summary>
            Returns the protocol buffer form of this descriptor.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.DescriptorBase`2.FullName">
            <summary>
            The fully qualified name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.DescriptorBase`2.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.DescriptorBase`2.File">
            <value>
            The file this descriptor was declared in.
            </value>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.DescriptorPool">
            <summary>
            Contains lookup tables containing all the descriptors defined in a particular file.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.FindSymbol``1(System.String)">
            <summary>
            Finds a symbol of the given name within the pool.
            </summary>
            <typeparam name="T">The type of symbol to look for</typeparam>
            <param name="fullName">Fully-qualified name to look up</param>
            <returns>The symbol with the given name and type,
            or null if the symbol doesn't exist or has the wrong type</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.AddPackage(System.String,Google.ProtocolBuffers.Descriptors.FileDescriptor)">
            <summary>
            Adds a package to the symbol tables. If a package by the same name
            already exists, that is fine, but if some other kind of symbol
            exists under the same name, an exception is thrown. If the package
            has multiple components, this also adds the parent package(s).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.AddSymbol(Google.ProtocolBuffers.Descriptors.IDescriptor)">
            <summary>
            Adds a symbol to the symbol table.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.Descriptors.DescriptorValidationException">The symbol already existed
            in the symbol table.</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.ValidateSymbolName(Google.ProtocolBuffers.Descriptors.IDescriptor)">
            <summary>
            Verifies that the descriptor's name is valid (i.e. it contains
            only letters, digits and underscores, and does not start with a digit).
            </summary>
            <param name="descriptor"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.FindFieldByNumber(Google.ProtocolBuffers.Descriptors.MessageDescriptor,System.Int32)">
            <summary>
            Returns the field with the given number in the given descriptor,
            or null if it can't be found.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.AddFieldByNumber(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Adds a field to the fieldsByNumber table.
            </summary>
            <exception cref="T:Google.ProtocolBuffers.Descriptors.DescriptorValidationException">A field with the same
            containing type and number already exists.</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.AddEnumValueByNumber(Google.ProtocolBuffers.Descriptors.EnumValueDescriptor)">
            <summary>
            Adds an enum value to the enumValuesByNumber table. If an enum value
            with the same type and number already exists, this method does nothing.
            (This is allowed; the first value defined with the number takes precedence.)
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorPool.LookupSymbol(System.String,Google.ProtocolBuffers.Descriptors.IDescriptor)">
            <summary>
            Looks up a descriptor by name, relative to some other descriptor.
            The name may be fully-qualified (with a leading '.'), partially-qualified,
            or unqualified. C++-like name lookup semantics are used to search for the
            matching descriptor.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.DescriptorPool.DescriptorIntPair">
            <summary>
            Struct used to hold the keys for the fieldByNumber table.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.DescriptorUtil">
            <summary>
            Internal class containing utility methods when working with descriptors.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.DescriptorUtil.ConvertAndMakeReadOnly``2(System.Collections.Generic.IList{``0},Google.ProtocolBuffers.Descriptors.DescriptorUtil.IndexedConverter{``0,``1})">
            <summary>
            Converts the given array into a read-only list, applying the specified conversion to
            each input element.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.DescriptorUtil.IndexedConverter`2">
            <summary>
            Equivalent to Func[TInput, int, TOutput] but usable in .NET 2.0. Only used to convert
            arrays.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.DescriptorValidationException">
            <summary>
            Thrown when building descriptors fails because the source DescriptorProtos
            are not valid.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.DescriptorValidationException.ProblemSymbolName">
            <value>
            The full name of the descriptor where the error occurred.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.DescriptorValidationException.ProblemProto">
            <value>
            The protocol message representation of the invalid descriptor.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.DescriptorValidationException.Description">
            <value>
            A human-readable description of the error. (The Message property
            is made up of the descriptor's name and this description.)
            </value>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.EnumDescriptor">
            <summary>
            Descriptor for an enum type in a .proto file.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.IndexedDescriptorBase`2">
            <summary>
            Base class for descriptors which are also indexed. This is all of them other than
            <see cref="T:Google.ProtocolBuffers.Descriptors.FileDescriptor"/>.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.IndexedDescriptorBase`2.Index">
            <value>
            The index of this descriptor within its parent descriptor. 
            </value>
            <remarks>
            This returns the index of this descriptor within its parent, for
            this descriptor's type. (There can be duplicate values for different
            types, e.g. one enum type with index 0 and one message type with index 0.)
            </remarks>
        </member>
        <member name="T:Google.ProtocolBuffers.IEnumLiteMap`1">
            <summary>
            Interface for an object which maps integers to {@link EnumLite}s.
            {@link Descriptors.EnumDescriptor} implements this interface by mapping
            numbers to {@link Descriptors.EnumValueDescriptor}s.  Additionally,
            every generated enum type has a static method internalGetValueMap() which
            returns an implementation of this type that maps numbers to enum values.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.EnumDescriptor.IsValidValue(Google.ProtocolBuffers.IEnumLite)">
            <summary>
            Logic moved from FieldSet to continue current behavior
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.EnumDescriptor.FindValueByNumber(System.Int32)">
            <summary>
            Finds an enum value by number. If multiple enum values have the
            same number, this returns the first defined value with that number.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.EnumDescriptor.FindValueByName(System.String)">
            <summary>
            Finds an enum value by name.
            </summary>
            <param name="name">The unqualified name of the value (e.g. "FOO").</param>
            <returns>The value's descriptor, or null if not found.</returns>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.EnumDescriptor.ContainingType">
            <value>
            If this is a nested type, get the outer descriptor, otherwise null.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.EnumDescriptor.Values">
            <value>
            An unmodifiable list of defined value descriptors for this enum.
            </value>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.EnumValueDescriptor">
            <summary>
            Descriptor for a single enum value within an enum in a .proto file.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IEnumLite">
            <summary>
            Interface for an enum value or value descriptor, to be used in FieldSet.
            The lite library stores enum values directly in FieldSets but the full
            library stores EnumValueDescriptors in order to better support reflection.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.FieldDescriptor">
            <summary>
            Descriptor for a field or extension within a message in a .proto file.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FieldDescriptor.GetFieldTypeFromProtoType(Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Type)">
            <summary>
            Maps a field type as included in the .proto file to a FieldType.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FieldDescriptor.GetDefaultValueForMappedType(Google.ProtocolBuffers.Descriptors.MappedType)">
            <summary>
            Returns the default value for a mapped type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FieldDescriptor.CompareTo(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Compares this descriptor with another one, ordering in "canonical" order
            which simply means ascending order by field number. <paramref name="other"/>
            must be a field of the same type, i.e. the <see cref="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.ContainingType"/> of
            both fields must be the same.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FieldDescriptor.CompareTo(Google.ProtocolBuffers.IFieldDescriptorLite)">
            <summary>
            Compares this descriptor with another one, ordering in "canonical" order
            which simply means ascending order by field number. <paramref name="other"/>
            must be a field of the same type, i.e. the <see cref="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.ContainingType"/> of
            both fields must be the same.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.Descriptors.FieldDescriptor.FieldTypeToMappedTypeMap">
            <summary>
            Immutable mapping from field type to mapped type. Built using the attributes on
            FieldType values.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FieldDescriptor.CrossLink">
            <summary>
            Look up and cross-link all field types etc.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.HasDefaultValue" -->
        <member name="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.DefaultValue">
            <value>
            The field's default value. Valid for all types except messages
            and groups. For all other types, the object returned is of the
            same class that would be returned by IMessage[this].
            For repeated fields this will always be an empty immutable list compatible with IList[object].
            For message fields it will always be null. For singular values, it will depend on the descriptor.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.IsExtension">
            <value>
            Indicates whether or not this field is an extension.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.ContainingType">
            <summary>
            Get the field's containing type. For extensions, this is the type being
            extended, not the location where the extension was defined. See
            <see cref="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.ExtensionScope"/>.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.CSharpOptions">
            <summary>
            Returns the C#-specific options for this field descriptor. This will always be
            completely filled in.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.ExtensionScope">
            <summary>
            For extensions defined nested within message types, gets
            the outer type. Not valid for non-extension fields.
            </summary>
            <example>
            <code>
            message Foo {
              extensions 1000 to max;
            }
            extend Foo {
              optional int32 baz = 1234;
            }
            message Bar {
              extend Foo {
                optional int32 qux = 4321;
              }
            }
            </code>
            The containing type for both <c>baz</c> and <c>qux</c> is <c>Foo</c>.
            However, the extension scope for <c>baz</c> is <c>null</c> while
            the extension scope for <c>qux</c> is <c>Bar</c>.
            </example>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.EnumType">
            <summary>
            For enum fields, returns the field's type.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FieldDescriptor.MessageType">
            <summary>
            For embedded message and group fields, returns the field's type.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.FieldMappingAttribute">
            <summary>
            Defined specifically for the <see cref="T:Google.ProtocolBuffers.Descriptors.FieldType"/> enumeration,
            this allows each field type to specify the mapped type and wire type.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.Descriptors.FieldMappingAttribute.FieldTypeToMappedTypeMap">
            <summary>
            Immutable mapping from field type to mapped type. Built using the attributes on
            FieldType values.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.FieldType">
            <summary>
            Enumeration of all the possible field types. The odd formatting is to make it very clear
            which attribute applies to which value, while maintaining a compact format.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.FileDescriptor">
            <summary>
            Describes a .proto file, including everything defined within.
            IDescriptor is implemented such that the File property returns this descriptor,
            and the FullName is the same as the Name.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FileDescriptor.ConfigureWithDefaultOptions(Google.ProtocolBuffers.DescriptorProtos.CSharpFileOptions)">
            <summary>
            Allows a file descriptor to be configured with a set of external options, e.g. from the
            command-line arguments to protogen.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FileDescriptor.FindTypeByName``1(System.String)">
            <summary>
            Finds a type (message, enum, service or extension) in the file by name. Does not find nested types.
            </summary>
            <param name="name">The unqualified type name to look for.</param>
            <typeparam name="T">The type of descriptor to look for (or ITypeDescriptor for any)</typeparam>
            <returns>The type's descriptor, or null if not found.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FileDescriptor.BuildFrom(Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto,Google.ProtocolBuffers.Descriptors.FileDescriptor[])">
            <summary>
            Builds a FileDescriptor from its protocol buffer representation.
            </summary>
            <param name="proto">The protocol message form of the FileDescriptor.</param>
            <param name="dependencies">FileDescriptors corresponding to all of the
            file's dependencies, in the exact order listed in the .proto file. May be null,
            in which case it is treated as an empty array.</param>
            <exception cref="T:Google.ProtocolBuffers.Descriptors.DescriptorValidationException">If <paramref name="proto"/> is not
            a valid descriptor. This can occur for a number of reasons, such as a field
            having an undefined type or because two messages were defined with the same name.</exception>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FileDescriptor.InternalBuildGeneratedFileFrom(System.Byte[],Google.ProtocolBuffers.Descriptors.FileDescriptor[])">
            <summary>
            This method is to be called by generated code only.  It is equivalent
            to BuildFrom except that the FileDescriptorProto is encoded in
            protocol buffer wire format. This overload is maintained for backward
            compatibility with source code generated before the custom options were available
            (and working).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.FileDescriptor.ReplaceProto(Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto)">
            <summary>
            Replace our FileDescriptorProto with the given one, which is
            identical except that it might contain extensions that weren't present
            in the original. This method is needed for bootstrapping when a file
            defines custom options. The options may be defined in the file itself,
            so we can't actually parse them until we've constructed the descriptors,
            but to construct the decsriptors we have to have parsed the descriptor
            protos. So, we have to parse the descriptor protos a second time after
            constructing the descriptors.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Proto">
            <value>
            The descriptor in its protocol message representation.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Options">
            <value>
            The <see cref="T:Google.ProtocolBuffers.DescriptorProtos.FileOptions"/> defined in <c>descriptor.proto</c>.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.CSharpOptions">
            <summary>
            Returns the C#-specific options for this file descriptor. This will always be
            completely filled in.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Name">
            <value>
            The file name.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Package">
            <summary>
            The package as declared in the .proto file. This may or may not
            be equivalent to the .NET namespace of the generated classes.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.MessageTypes">
            <value>
            Unmodifiable list of top-level message types declared in this file.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.EnumTypes">
            <value>
            Unmodifiable list of top-level enum types declared in this file.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Services">
            <value>
            Unmodifiable list of top-level services declared in this file.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Extensions">
            <value>
            Unmodifiable list of top-level extensions declared in this file.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Dependencies">
            <value>
            Unmodifiable list of this file's dependencies (imports).
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Google#ProtocolBuffers#Descriptors#IDescriptor#FullName">
            <value>
            Implementation of IDescriptor.FullName - just returns the same as Name.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Google#ProtocolBuffers#Descriptors#IDescriptor#File">
            <value>
            Implementation of IDescriptor.File - just returns this descriptor.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.Google#ProtocolBuffers#Descriptors#IDescriptor#Proto">
            <value>
            Protocol buffer describing this descriptor.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.FileDescriptor.DescriptorPool">
            <value>
            Pool containing symbol descriptors.
            </value>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.FileDescriptor.InternalDescriptorAssigner">
            <summary>
            This delegate should be used by generated code only. When calling
            FileDescriptor.InternalBuildGeneratedFileFrom, the caller can provide
            a callback which assigns the global variables defined in the generated code
            which point at parts of the FileDescriptor. The callback returns an
            Extension Registry which contains any extensions which might be used in
            the descriptor - that is, extensions of the various "Options" messages defined
            in descriptor.proto. The callback may also return null to indicate that
            no extensions are used in the descriptor.
            </summary>
            <param name="descriptor"></param>
            <returns></returns>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.MappedType">
            <summary>
            Type as it's mapped onto a .NET type.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.MessageDescriptor">
            <summary>
            Describes a message type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.MessageDescriptor.IsExtensionNumber(System.Int32)">
            <summary>
            Determines if the given field number is an extension.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.MessageDescriptor.FindFieldByName(System.String)">
            <summary>
            Finds a field by field name.
            </summary>
            <param name="name">The unqualified name of the field (e.g. "foo").</param>
            <returns>The field's descriptor, or null if not found.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.MessageDescriptor.FindFieldByNumber(System.Int32)">
            <summary>
            Finds a field by field number.
            </summary>
            <param name="number">The field number within this message type.</param>
            <returns>The field's descriptor, or null if not found.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.MessageDescriptor.FindFieldByPropertyName(System.String)">
            <summary>
            Finds a field by its property name, as it would be generated by protogen.
            </summary>
            <param name="propertyName">The property name within this message type.</param>
            <returns>The field's descriptor, or null if not found.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.MessageDescriptor.FindDescriptor``1(System.String)">
            <summary>
            Finds a nested descriptor by name. The is valid for fields, nested
            message types and enums.
            </summary>
            <param name="name">The unqualified name of the descriptor, e.g. "Foo"</param>
            <returns>The descriptor, or null if not found.</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.MessageDescriptor.CrossLink">
            <summary>
            Looks up and cross-links all fields, nested types, and extensions.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.MessageDescriptor.ReplaceProto(Google.ProtocolBuffers.DescriptorProtos.DescriptorProto)">
            <summary>
            See FileDescriptor.ReplaceProto
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MessageDescriptor.ContainingType">
            <value>
            If this is a nested type, get the outer descriptor, otherwise null.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MessageDescriptor.Fields">
            <value>
            An unmodifiable list of this message type's fields.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MessageDescriptor.Extensions">
            <value>
            An unmodifiable list of this message type's extensions.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MessageDescriptor.NestedTypes">
            <value>
            An unmodifiable list of this message type's nested types.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MessageDescriptor.EnumTypes">
            <value>
            An unmodifiable list of this message type's enum types.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MessageDescriptor.HasRequiredFields">
            <summary>
            Returns a pre-computed result as to whether this message
            has required fields. This includes optional fields which are
            message types which in turn have required fields, and any 
            extension fields.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.MethodDescriptor">
            <summary>
            Describes a single method in a service.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MethodDescriptor.Service">
            <value>
            The service this method belongs to.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MethodDescriptor.InputType">
            <value>
            The method's input type.
            </value>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.MethodDescriptor.OutputType">
            <value>
            The method's input type.
            </value>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.PackageDescriptor">
            <summary>
            Represents a package in the symbol table.  We use PackageDescriptors
            just as placeholders so that someone cannot define, say, a message type
            that has the same name as an existing package.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.Descriptors.ServiceDescriptor">
            <summary>
            Describes a service type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.Descriptors.ServiceDescriptor.FindMethodByName(System.String)">
            <summary>
            Finds a method by name.
            </summary>
            <param name="name">The unqualified name of the method (e.g. "Foo").</param>
            <returns>The method's decsriptor, or null if not found.</returns>
        </member>
        <member name="P:Google.ProtocolBuffers.Descriptors.ServiceDescriptor.Methods">
            <value>
            An unmodifiable list of methods in this service.
            </value>
        </member>
        <member name="M:Google.ProtocolBuffers.EnumParser`1.TryConvert(System.Int32,`0@)">
            <summary>
            Tries to convert an integer to its enum representation. This would take an out parameter,
            but the caller uses ref, so this approach is simpler.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.EnumParser`1.TryConvert(System.String,`0@)">
            <summary>
            Tries to convert a string to its enum representation. This would take an out parameter,
            but the caller uses ref, so this approach is simpler.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtensionInfo.Descriptor">
            <summary>
            The extension's descriptor
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtensionInfo.DefaultInstance">
            <summary>
            A default instance of the extensions's type, if it has a message type,
            or null otherwise.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ExtensionRegistry">
             <summary>
             A table of known extensions, searchable by name or field number.  When
             parsing a protocol message that might have extensions, you must provide
             an <see cref="T:Google.ProtocolBuffers.ExtensionRegistry"/> in which you have registered any extensions
             that you want to be able to parse.  Otherwise, those extensions will just
             be treated like unknown fields.
             </summary>
             <example>
             For example, if you had the <c>.proto</c> file:
             <code>
             option java_class = "MyProto";
            
             message Foo {
               extensions 1000 to max;
             }
            
             extend Foo {
               optional int32 bar;
             }
             </code>
            
             Then you might write code like:
            
             <code>
             ExtensionRegistry registry = ExtensionRegistry.CreateInstance();
             registry.Add(MyProto.Bar);
             MyProto.Foo message = MyProto.Foo.ParseFrom(input, registry);
             </code>
             </example>
            
             <remarks>
             <para>You might wonder why this is necessary. Two alternatives might come to
             mind. First, you might imagine a system where generated extensions are
             automatically registered when their containing classes are loaded. This
             is a popular technique, but is bad design; among other things, it creates a
             situation where behavior can change depending on what classes happen to be
             loaded. It also introduces a security vulnerability, because an
             unprivileged class could cause its code to be called unexpectedly from a
             privileged class by registering itself as an extension of the right type.
             </para>
             <para>Another option you might consider is lazy parsing: do not parse an
             extension until it is first requested, at which point the caller must
             provide a type to use. This introduces a different set of problems. First,
             it would require a mutex lock any time an extension was accessed, which
             would be slow. Second, corrupt data would not be detected until first
             access, at which point it would be much harder to deal with it. Third, it
             could violate the expectation that message objects are immutable, since the
             type provided could be any arbitrary message class. An unprivileged user
             could take advantage of this to inject a mutable object into a message
             belonging to privileged code and create mischief.</para>
             </remarks>
             <summary>
             A table of known extensions, searchable by name or field number.  When
             parsing a protocol message that might have extensions, you must provide
             an <see cref="T:Google.ProtocolBuffers.ExtensionRegistry"/> in which you have registered any extensions
             that you want to be able to parse.  Otherwise, those extensions will just
             be treated like unknown fields.
             </summary>
             <example>
             For example, if you had the <c>.proto</c> file:
             <code>
             option java_class = "MyProto";
            
             message Foo {
               extensions 1000 to max;
             }
            
             extend Foo {
               optional int32 bar;
             }
             </code>
            
             Then you might write code like:
            
             <code>
             extensionRegistry registry = extensionRegistry.CreateInstance();
             registry.Add(MyProto.Bar);
             MyProto.Foo message = MyProto.Foo.ParseFrom(input, registry);
             </code>
             </example>
            
             <remarks>
             <para>You might wonder why this is necessary. Two alternatives might come to
             mind. First, you might imagine a system where generated extensions are
             automatically registered when their containing classes are loaded. This
             is a popular technique, but is bad design; among other things, it creates a
             situation where behavior can change depending on what classes happen to be
             loaded. It also introduces a security vulnerability, because an
             unprivileged class could cause its code to be called unexpectedly from a
             privileged class by registering itself as an extension of the right type.
             </para>
             <para>Another option you might consider is lazy parsing: do not parse an
             extension until it is first requested, at which point the caller must
             provide a type to use. This introduces a different set of problems. First,
             it would require a mutex lock any time an extension was accessed, which
             would be slow. Second, corrupt data would not be detected until first
             access, at which point it would be much harder to deal with it. Third, it
             could violate the expectation that message objects are immutable, since the
             type provided could be any arbitrary message class. An unprivileged user
             could take advantage of this to inject a mutable object into a message
             belonging to privileged code and create mischief.</para>
             </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtensionRegistry.Add``1(Google.ProtocolBuffers.GeneratedExtensionBase{``0})">
            <summary>
            Add an extension from a generated file to the registry.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtensionRegistry.Add(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Adds a non-message-type extension to the registry by descriptor.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtensionRegistry.Add(Google.ProtocolBuffers.Descriptors.FieldDescriptor,Google.ProtocolBuffers.IMessage)">
            <summary>
            Adds a message-type-extension to the registry by descriptor.
            </summary>
            <param name="type"></param>
            <param name="defaultInstance"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtensionRegistry.CreateInstance">
            <summary>
            Construct a new, empty instance.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ExtensionRegistry.Add(Google.ProtocolBuffers.IGeneratedExtensionLite)">
            <summary>
            Add an extension from a generated file to the registry.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtensionRegistry.Item(System.String)">
            <summary>
            Finds an extension by fully-qualified field name, in the
            proto namespace, i.e. result.Descriptor.FullName will match
            <paramref name="fullName"/> if a match is found. A null
            reference is returned if the extension can't be found.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtensionRegistry.Item(Google.ProtocolBuffers.Descriptors.MessageDescriptor,System.Int32)">
            <summary>
            Finds an extension by containing type and field number.
            A null reference is returned if the extension can't be found.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtensionRegistry.Empty">
            <summary>
            Get the unmodifiable singleton empty instance.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtensionRegistry.Item(Google.ProtocolBuffers.IMessageLite,System.Int32)">
            <summary>
            Finds an extension by containing type and field number.
            A null reference is returned if the extension can't be found.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ExtensionRegistry.ExtensionIntPair">
            <summary>
            Nested type just used to represent a pair of MessageDescriptor and int, as
            the key into the "by number" map.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.ReflectionUtil">
            <summary>
            The methods in this class are somewhat evil, and should not be tampered with lightly.
            Basically they allow the creation of relatively weakly typed delegates from MethodInfos
            which are more strongly typed. They do this by creating an appropriate strongly typed
            delegate from the MethodInfo, and then calling that within an anonymous method.
            Mind-bending stuff (at least to your humble narrator) but the resulting delegates are
            very fast compared with calling Invoke later on.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.FieldAccess.ReflectionUtil.EmptyTypes">
            <summary>
            Empty Type[] used when calling GetProperty to force property instead of indexer fetching.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.ReflectionUtil.CreateUpcastDelegate``1(System.Reflection.MethodInfo)">
            <summary>
            Creates a delegate which will execute the given method and then return
            the result as an object.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.ReflectionUtil.CreateUpcastDelegateImpl``2(System.Reflection.MethodInfo)">
            <summary>
            Method used solely for implementing CreateUpcastDelegate. Public to avoid trust issues
            in low-trust scenarios.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.ReflectionUtil.CreateDowncastDelegate``1(System.Reflection.MethodInfo)">
            <summary>
            Creates a delegate which will execute the given method after casting the parameter
            down from object to the required parameter type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.ReflectionUtil.CreateDowncastDelegateIgnoringReturn``1(System.Reflection.MethodInfo)">
            <summary>
            Creates a delegate which will execute the given method after casting the parameter
            down from object to the required parameter type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.ReflectionUtil.CreateStaticUpcastDelegate(System.Reflection.MethodInfo)">
            <summary>
            Creates a delegate which will execute the given static method and cast the result up to IBuilder.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.SingleEnumAccessor`2">
            <summary>
            Accessor for fields representing a non-repeated enum value.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.SinglePrimitiveAccessor`2">
            <summary>
            Access for a non-repeated field of a "primitive" type (i.e. not another message or an enum).
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2">
            <summary>
            Allows fields to be reflectively accessed in a smart manner.
            The property descriptors for each field are created once and then cached.
            In addition, this interface holds knowledge of repeated fields, builders etc.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.Has(`0)">
            <summary>
            Indicates whether the specified message contains the field.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.GetRepeatedCount(`0)">
            <summary>
            Gets the count of the repeated field in the specified message.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.Clear(`1)">
            <summary>
            Clears the field in the specified builder.
            </summary>
            <param name="builder"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.CreateBuilder">
            <summary>
            Creates a builder for the type of this field (which must be a message field).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.GetValue(`0)">
            <summary>
            Accessor for single fields
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.SetValue(`1,System.Object)">
            <summary>
            Mutator for single fields
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.GetRepeatedValue(`0,System.Int32)">
            <summary>
            Accessor for repeated fields
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.SetRepeated(`1,System.Int32,System.Object)">
            <summary>
            Mutator for repeated fields
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.AddRepeated(`1,System.Object)">
            <summary>
            Adds the specified value to the field in the given builder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.IFieldAccessor`2.GetRepeatedWrapper(`1)">
            <summary>
            Returns a read-only wrapper around the value of a repeated field.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.SinglePrimitiveAccessor`2.CreateBuilder">
            <summary>
            Only valid for message types - this implementation throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldAccess.SinglePrimitiveAccessor`2.ClrType">
            <summary>
            The CLR type of the field (int, the enum type, ByteString, the message etc).
            As declared by the property.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.SingleEnumAccessor`2.GetValue(`0)">
            <summary>
            Returns an EnumValueDescriptor representing the value in the builder.
            Note that if an enum has multiple values for the same number, the descriptor
            for the first value with that number will be returned.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.SingleEnumAccessor`2.SetValue(`1,System.Object)">
            <summary>
            Sets the value as an enum (via an int) in the builder,
            from an EnumValueDescriptor parameter.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.SingleMessageAccessor`2">
            <summary>
            Accessor for fields representing a non-repeated message value.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.FieldAccess.SingleMessageAccessor`2.createBuilderDelegate">
            <summary>
            The static method to create a builder for the property type. For example,
            in a message type "Foo", a field called "bar" might be of type "Baz". This
            method is Baz.CreateBuilder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.SingleMessageAccessor`2.CoerceType(System.Object)">
            <summary>
            Creates a message of the appropriate CLR type from the given value,
            which may already be of the right type or may be a dynamic message.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.RepeatedPrimitiveAccessor`2">
            <summary>
            Accessor for a repeated field of type int, ByteString etc.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.RepeatedPrimitiveAccessor`2.GetRepeatedWrapper(`1)">
            <summary>
            The builder class's accessor already builds a read-only wrapper for
            us, which is exactly what we want.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldAccess.RepeatedPrimitiveAccessor`2.ClrType">
            <summary>
            The CLR type of the field (int, the enum type, ByteString, the message etc).
            This is taken from the return type of the method used to retrieve a single
            value.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.RepeatedEnumAccessor`2">
            <summary>
            Accessor for a repeated enum field.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.FieldAccessorTable`2">
            <summary>
            Provides access to fields in generated messages via reflection.
            This type is public to allow it to be used by generated messages, which
            create appropriate instances in the .proto file description class.
            TODO(jonskeet): See if we can hide it somewhere...
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.FieldAccessorTable`2.#ctor(Google.ProtocolBuffers.Descriptors.MessageDescriptor,System.String[])">
            <summary>
            Constructs a FieldAccessorTable for a particular message class.
            Only one FieldAccessorTable should be constructed per class.
            The property names should all actually correspond with the field descriptor's
            CSharpOptions.PropertyName property, but bootstrapping issues currently
            prevent us from using that. This may be addressed at a future time, in which case
            we can keep this constructor for backwards compatibility, just ignoring the parameter.
            TODO(jonskeet): Make it so.
            </summary>
            <param name="descriptor">The type's descriptor</param>
            <param name="propertyNames">The Pascal-case names of all the field-based properties in the message.</param>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.FieldAccessorTable`2.CreateAccessor(Google.ProtocolBuffers.Descriptors.FieldDescriptor,System.String)">
            <summary>
            Creates an accessor for a single field
            </summary>   
        </member>
        <member name="T:Google.ProtocolBuffers.FieldAccess.RepeatedMessageAccessor`2">
            <summary>
            Accessor for a repeated message field.
            
            TODO(jonskeet): Try to extract the commonality between this and SingleMessageAccessor.
            We almost want multiple inheritance...
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.FieldAccess.RepeatedMessageAccessor`2.createBuilderDelegate">
            <summary>
            The static method to create a builder for the property type. For example,
            in a message type "Foo", a field called "bar" might be of type "Baz". This
            method is Baz.CreateBuilder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldAccess.RepeatedMessageAccessor`2.CoerceType(System.Object)">
            <summary>
            Creates a message of the appropriate CLR type from the given value,
            which may already be of the right type or may be a dynamic message.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FieldSet">
            <summary>
            A class which represents an arbitrary set of fields of some message type.
            This is used to implement DynamicMessage, and also to represent extensions
            in GeneratedMessage. This class is internal, since outside users should probably
            be using DynamicMessage.
            
            As in the Java implementation, this class goes against the rest of the framework
            in terms of mutability. Instead of having a mutable Builder class and an immutable
            FieldSet class, FieldSet just has a MakeImmutable() method. This is safe so long as
            all callers are careful not to let a mutable FieldSet escape into the open. This would
            be impossible to guarantee if this were a public class, of course.
            
            All repeated fields are stored as IList[object] even 
            TODO(jonskeet): Finish this comment!
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.MakeImmutable">
            <summary>
            Makes this FieldSet immutable, and returns it for convenience. Any
            mutable repeated fields are made immutable, as well as the map itself.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.HasField(Google.ProtocolBuffers.IFieldDescriptorLite)">
            <summary>
            See <see cref="!:IMessageLite.HasField"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.Clear">
            <summary>
            Clears all fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.AddRepeatedField(Google.ProtocolBuffers.IFieldDescriptorLite,System.Object)">
            <summary>
            See <see cref="M:Google.ProtocolBuffers.IBuilder`2.AddRepeatedField(Google.ProtocolBuffers.Descriptors.FieldDescriptor,System.Object)"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.GetEnumerator">
            <summary>
            Returns an enumerator for the field map. Used to write the fields out.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.IsInitializedWithRespectTo(System.Collections.IEnumerable)">
            <summary>
            Verifies whether all the required fields in the specified message
            descriptor are present in this field set, as well as whether
            all the embedded messages are themselves initialized.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.ClearField(Google.ProtocolBuffers.IFieldDescriptorLite)">
            <summary>
            See <see cref="M:Google.ProtocolBuffers.IBuilder`2.ClearField(Google.ProtocolBuffers.Descriptors.FieldDescriptor)"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.GetRepeatedFieldCount(Google.ProtocolBuffers.IFieldDescriptorLite)">
            <summary>
            See <see cref="!:IMessageLite.GetRepeatedFieldCount"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.MergeFrom(Google.ProtocolBuffers.IMessage)">
            <summary>
            See <see cref="!:IBuilder&lt;TMessage, TBuilder&gt;.MergeFrom(IMessageLite)"/>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.MergeFrom(Google.ProtocolBuffers.FieldSet)">
            <summary>
            Implementation of both <c>MergeFrom</c> methods.
            </summary>
            <param name="otherFields"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.WriteTo(Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            See <see cref="!:IMessageLite.WriteTo(CodedOutputStream)"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.WriteField(Google.ProtocolBuffers.IFieldDescriptorLite,System.Object,Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Writes a single field to a CodedOutputStream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.FieldSet.VerifyType(Google.ProtocolBuffers.IFieldDescriptorLite,System.Object)">
            <summary>
            Verifies that the given object is of the correct type to be a valid
            value for the given field.
            </summary>
            <remarks>
            For repeated fields, this checks if the object is of the right
            element type, not whether it's a list.
            </remarks>
            <exception cref="T:System.ArgumentException">The value is not of the right type.</exception>
            <exception cref="T:System.ArgumentNullException">The value is null.</exception>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldSet.DefaultInstance">
            <summary>
            Returns the default, immutable instance with no fields defined.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldSet.AllFields">
            <summary>
            Returns an immutable mapping of fields. Note that although the mapping itself
            is immutable, the entries may not be (i.e. any repeated values are represented by
            mutable lists). The behaviour is not specified if the contents are mutated.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldSet.AllFieldDescriptors">
            <summary>
            Force coercion to full descriptor dictionary.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldSet.Item(Google.ProtocolBuffers.IFieldDescriptorLite)">
            <summary>
            See <see cref="!:IMessageLite.Item(IFieldDescriptorLite)"/>
            </summary>
            <remarks>
            If the field is not set, the behaviour when fetching this property varies by field type:
            <list>
            <item>For singular message values, null is returned.</item>
            <item>For singular non-message values, the default value of the field is returned.</item>
            <item>For repeated values, an empty immutable list is returned. This will be compatible
            with IList[object], regardless of the type of the repeated item.</item>
            </list>
            This method returns null if the field is a singular message type
            and is not set; in this case it is up to the caller to fetch the 
            message's default instance. For repeated fields of message types, 
            an empty collection is returned. For repeated fields of non-message
            types, null is returned.
            <para/>
            When setting this property, any list values are copied, and each element is checked
            to ensure it is of an appropriate type.
            </remarks>
            
        </member>
        <member name="P:Google.ProtocolBuffers.FieldSet.Item(Google.ProtocolBuffers.IFieldDescriptorLite,System.Int32)">
            <summary>
            See <see cref="!:IMessageLite.Item(IFieldDescriptorLite,int)"/>
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldSet.IsInitialized">
            <summary>
            See <see cref="P:Google.ProtocolBuffers.IMessageLite.IsInitialized"/>
            </summary>
            <remarks>
            Since FieldSet itself does not have any way of knowing about
            required fields that aren't actually present in the set, it is up
            to the caller to check for genuinely required fields. This property
            merely checks that any messages present are themselves initialized.
            </remarks>
        </member>
        <member name="P:Google.ProtocolBuffers.FieldSet.SerializedSize">
            <summary>
            See <see cref="P:Google.ProtocolBuffers.IMessageLite.SerializedSize"/>. It's up to the caller to
            cache the resulting size if desired.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.FrameworkPortability">
            <summary>
            Class containing helpful workarounds for various platform compatibility
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.ExtensionDescriptorLite.MessageSetWireFormat">
            <summary>
            This is not supported and assertions are made to ensure this does not exist on extensions of Lite types
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedExtensionLite`2.#ctor(System.String,`0,`1,Google.ProtocolBuffers.IMessageLite,Google.ProtocolBuffers.IEnumLiteMap,System.Int32,Google.ProtocolBuffers.Descriptors.FieldType)">
            For use by generated code only. 
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedExtensionLite`2.#ctor(System.String,`0,`1,Google.ProtocolBuffers.IMessageLite,Google.ProtocolBuffers.IEnumLiteMap,System.Int32,Google.ProtocolBuffers.Descriptors.FieldType,System.Boolean)">
            Repeating fields: For use by generated code only. 
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedExtensionLite`2.ToReflectionType(System.Object)">
            <summary>
            Converts from the type used by the native accessors to the type
            used by reflection accessors. For example, the reflection accessors
            for enums use EnumValueDescriptors but the native accessors use
            the generated enum type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedExtensionLite`2.SingularToReflectionType(System.Object)">
            <summary>
            Like ToReflectionType(object) but for a single element.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedExtensionLite`2.Descriptor">
            <summary>
            Returns information about this extension
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedExtensionLite`2.DefaultValue">
            <summary>
            Returns the default value for this extension
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedExtensionLite`2.Google#ProtocolBuffers#IGeneratedExtensionLite#ContainingType">
            <summary>
            used for the extension registry
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedExtensionLite`2.ContainingTypeDefaultInstance">
            Default instance of the type being extended, used to identify that type.
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedExtensionLite`2.Number">
            Get the field number. 
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedExtensionLite`2.MessageDefaultInstance">
            If the extension is an embedded message, this is the default instance of
            that type.
        </member>
        <member name="T:Google.ProtocolBuffers.GeneratedRepeatExtension`1">
            <summary>
            Class used to represent repeat extensions in generated classes.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.GeneratedExtensionBase`1">
            <summary>
            Base type for all generated extensions.
            </summary>
            <remarks>
            The protocol compiler generates a static singleton instance of this
            class for each extension. For exmaple, imagine a .proto file with:
            <code>
            message Foo {
              extensions 1000 to max
            }
            
            extend Foo {
              optional int32 bar;
            }
            </code>
            Then MyProto.Foo.Bar has type GeneratedExtensionBase&lt;MyProto.Foo,int&gt;.
            <para />
            In general, users should ignore the details of this type, and
            simply use the static singletons as parameters to the extension accessors
            in ExtendableMessage and ExtendableBuilder.
            The interface implemented by both GeneratedException and GeneratedRepeatException,
            to make it easier to cope with repeats separately.
            </remarks>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedExtensionBase`1.ToReflectionType(System.Object)">
            <summary>
            Converts from the type used by the native accessors to the type
            used by reflection accessors. For example, the reflection accessors
            for enums use EnumValueDescriptors but the native accessors use
            the generated enum type.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedExtensionBase`1.SingularToReflectionType(System.Object)">
            <summary>
            Like ToReflectionType(object) but for a single element.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.GeneratedExtensionBase`1.MessageDefaultInstance">
            <summary>
            Returns the default message instance for extensions which are message types.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.GeneratedRepeatExtension`1.FromReflectionType(System.Object)">
            <summary>
            Converts the list to the right type.
            TODO(jonskeet): Check where this is used, and whether we need to convert
            for primitive types.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Google.ProtocolBuffers.GeneratedSingleExtension`1" -->
        <member name="T:Google.ProtocolBuffers.InvalidProtocolBufferException">
            <summary>
            Thrown when a protocol message being parsed is invalid in some way,
            e.g. it contains a malformed varint or a negative byte length.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IRpcChannel">
            <summary>
            Interface for an RPC channel. A channel represents a communication line to
            a service (IService implementation) which can be used to call that service's
            methods. The service may be running on another machine. Normally, you should
            not call an IRpcChannel directly, but instead construct a stub wrapping it.
            Generated service classes contain a CreateStub method for precisely this purpose.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcChannel.CallMethod(Google.ProtocolBuffers.Descriptors.MethodDescriptor,Google.ProtocolBuffers.IRpcController,Google.ProtocolBuffers.IMessage,Google.ProtocolBuffers.IMessage,System.Action{Google.ProtocolBuffers.IMessage})">
            <summary>
            Calls the given method of the remote service. This method is similar
            to <see cref="M:Google.ProtocolBuffers.IService.CallMethod(Google.ProtocolBuffers.Descriptors.MethodDescriptor,Google.ProtocolBuffers.IRpcController,Google.ProtocolBuffers.IMessage,System.Action{Google.ProtocolBuffers.IMessage})"/> with one important difference: the
            caller decides the types of the IMessage objects, not the implementation.
            The request may be of any type as long as <c>request.Descriptor == method.InputType</c>.
            The response passed to the callback will be of the same type as
            <paramref name="responsePrototype"/> (which must be such that
            <c>responsePrototype.Descriptor == method.OutputType</c>).
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IRpcController">
            <summary>
            Mediates a single method call. The primary purpose of the controller
            is to provide a way to manipulate settings specific to the
            RPC implementation and to find out about RPC-level errors.
            
            The methods provided by this interface are intended to be a "least
            common denominator" set of features which we expect all implementations to
            support. Specific implementations may provide more advanced features,
            (e.g. deadline propagation).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcController.Reset">
            <summary>
            Resets the controller to its initial state so that it may be reused in
            a new call.  This can be called from the client side only.  It must not
            be called while an RPC is in progress.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcController.StartCancel">
            <summary>
            Advises the RPC system that the caller desires that the RPC call be
            canceled. The RPC system may cancel it immediately, may wait awhile and
            then cancel it, or may not even cancel the call at all. If the call is
            canceled, the "done" callback will still be called and the RpcController
            will indicate that the call failed at that time.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcController.SetFailed(System.String)">
            <summary>
            Causes Failed to return true on the client side. <paramref name="reason"/>
            will be incorporated into the message returned by ErrorText.
            If you find you need to return machine-readable information about
            failures, you should incorporate it into your response protocol buffer
            and should *not* call SetFailed.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcController.IsCanceled">
            <summary>
            If true, indicates that the client canceled the RPC, so the server may as
            well give up on replying to it. This method must be called on the server
            side only. The server should still call the final "done" callback.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcController.NotifyOnCancel(System.Action{System.Object})">
            <summary>
            Requests that the given callback be called when the RPC is canceled.
            The parameter passed to the callback will always be null. The callback will
            be called exactly once. If the RPC completes without being canceled, the
            callback will be called after completion. If the RPC has already been canceled
            when NotifyOnCancel is called, the callback will be called immediately.
            
            NotifyOnCancel must be called no more than once per request. It must be
            called on the server side only.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="P:Google.ProtocolBuffers.IRpcController.Failed">
            <summary>
            After a call has finished, returns true if the call failed.  The possible
            reasons for failure depend on the RPC implementation. Failed must
            only be called on the client side, and must not be called before a call has
            finished.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IRpcController.ErrorText">
            <summary>
            If Failed is true, ErrorText returns a human-readable description of the error.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.IRpcServerStub">
            <summary>
            Provides an entry-point for transport listeners to call a specified method on a service
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcServerStub.CallMethod(System.String,Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Calls the method identified by methodName and returns the message
            </summary>
            <param name="methodName">The method name on the service descriptor (case-sensitive)</param>
            <param name="input">The ICodedInputStream to deserialize the call parameter from</param>
            <param name="registry">The extension registry to use when deserializing the call parameter</param>
            <returns>The message that was returned from the service's method</returns>
        </member>
        <member name="T:Google.ProtocolBuffers.IRpcDispatch">
            <summary>
            Used to forward an invocation of a service method to a transport sender implementation
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IRpcDispatch.CallMethod``2(System.String,Google.ProtocolBuffers.IMessageLite,Google.ProtocolBuffers.IBuilderLite{``0,``1})">
            <summary>
            Calls the service member on the endpoint connected.  This is generally done by serializing
            the message, sending the bytes over a transport, and then deserializing the call parameter
            to invoke the service's actual implementation via IRpcServerStub.  Once the call has
            completed the result message is serialized and returned to the originating endpoint.
            </summary>
            <typeparam name="TMessage">The type of the response message</typeparam>
            <typeparam name="TBuilder">The type of of the response builder</typeparam>
            <param name="method">The name of the method on the service</param>
            <param name="request">The message instance provided to the service call</param>
            <param name="response">The builder used to deserialize the response</param>
            <returns>The resulting message of the service call</returns>
        </member>
        <member name="T:Google.ProtocolBuffers.IService">
            <summary>
            Base interface for protocol-buffer-based RPC services. Services themselves
            are abstract classes (implemented either by servers or as stubs) but they
            implement this itnerface. The methods of this interface can be used to call
            the methods of the service without knowing its exact type at compile time
            (analagous to the IMessage interface).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IService.CallMethod(Google.ProtocolBuffers.Descriptors.MethodDescriptor,Google.ProtocolBuffers.IRpcController,Google.ProtocolBuffers.IMessage,System.Action{Google.ProtocolBuffers.IMessage})">
            <summary>
            Call a method of the service specified by MethodDescriptor.  This is
            normally implemented as a simple switch that calls the standard
            definitions of the service's methods.
            <para>
            Preconditions
            <list>
            <item><c>method.Service == DescriptorForType</c></item>
            <item>request is of the exact same class as the object returned by GetRequestPrototype(method)</item>
            <item>controller is of the correct type for the RPC implementation being used by this service.
            For stubs, the "correct type" depends on the IRpcChannel which the stub is using. Server-side
            implementations are expected to accept whatever type of IRpcController the server-side RPC implementation
            uses.</item>
            </list>
            </para>
            <para>
            Postconditions
            <list>
            <item><paramref name="done"/> will be called when the method is complete.
            This may before CallMethod returns or it may be at some point in the future.</item>
            <item>The parameter to <paramref name="done"/> is the response. It will be of the
            exact same type as would be returned by <see cref="M:Google.ProtocolBuffers.IService.GetResponsePrototype(Google.ProtocolBuffers.Descriptors.MethodDescriptor)"/>.</item>
            <item>If the RPC failed, the parameter to <paramref name="done"/> will be null.
            Further details about the failure can be found by querying <paramref name="controller"/>.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IService.GetRequestPrototype(Google.ProtocolBuffers.Descriptors.MethodDescriptor)">
            <summary>
            CallMethod requires that the request passed in is of a particular implementation
            of IMessage. This method gets the default instance of this type of a given method.
            You can then call WeakCreateBuilderForType to create a builder to build an object which
            you can then pass to CallMethod.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.IService.GetResponsePrototype(Google.ProtocolBuffers.Descriptors.MethodDescriptor)">
            <summary>
            Like GetRequestPrototype, but returns a prototype of the response message.
            This is generally not needed because the IService implementation contructs
            the response message itself, but it may be useful in some cases to know ahead
            of time what type of object will be returned.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.IService.DescriptorForType">
            <summary>
            The ServiceDescriptor describing this service and its methods.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.MessageStreamIterator`1">
            <summary>
            Iterates over data created using a <see cref="T:Google.ProtocolBuffers.MessageStreamWriter`1"/>.
            Unlike MessageStreamWriter, this class is not usually constructed directly with
            a stream; instead it is provided with a way of opening a stream when iteration
            is started. The stream is closed when the iteration is completed or the enumerator
            is disposed. (This occurs naturally when using <c>foreach</c>.)
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.MessageStreamIterator`1.defaultMessageInstance">
            <summary>
            The default instance of TMessage type used to construct builders while reading
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.MessageStreamIterator`1.typeInitializationException">
            <summary>
            Any exception (within reason) thrown in type ctor is caught and rethrown in the constructor.
            This makes life a lot simpler for the caller.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.MessageStreamIterator`1.CreateDefaultInstance">
            <summary>
            Vastly simplified the reflection to simply obtain the default instance and use it to construct
            the weak builder while simply casting the result.  Ideally this class should have required a 
            TBuilder type argument with a new() constraint to construct the initial instance thereby the
            reflection could be eliminated.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.MessageStreamIterator`1.WithExtensionRegistry(Google.ProtocolBuffers.ExtensionRegistry)">
            <summary>
            Creates a new instance which uses the same stream provider as this one,
            but the specified extension registry.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.MessageStreamIterator`1.WithSizeLimit(System.Int32)">
            <summary>
            Creates a new instance which uses the same stream provider and extension registry as this one,
            but with the specified size limit. Note that this must be big enough for the largest message
            and the tag and size preceding it.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.MessageStreamWriter`1">
            <summary>
            Writes multiple messages to the same stream. Each message is written
            as if it were an element of a repeated field 1 in a larger protocol buffer.
            This class takes no ownership of the stream it is given; it never closes the
            stream.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.MessageStreamWriter`1.#ctor(System.IO.Stream)">
            <summary>
            Creates an instance which writes to the given stream.
            </summary>
            <param name="output">Stream to write messages to.</param>
        </member>
        <member name="T:Google.ProtocolBuffers.MessageUtil">
            <summary>
            Utilities for arbitrary messages of an unknown type. This class does not use
            generics precisely because it is designed for dynamically discovered types.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.MessageUtil.GetDefaultMessage(System.Type)">
            <summary>
            Returns the default message for the given type. If an exception is thrown
            (directly from this code), the message will be suitable to be displayed to a user.
            </summary>
            <param name="type"></param>
            <exception cref="T:System.ArgumentNullException">The type parameter is null.</exception>
            <exception cref="T:System.ArgumentException">The type doesn't implement IMessage, or doesn't
            have a static DefaultMessage property of the same type, or is generic or abstract.</exception>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.MessageUtil.GetDefaultMessage(System.String)">
            <summary>
            Returns the default message for the type with the given name. This is just
            a convenience wrapper around calling Type.GetType and then GetDefaultMessage.
            If an exception is thrown, the message will be suitable to be displayed to a user.
            </summary>
            <param name="typeName"></param>
            <exception cref="T:System.ArgumentNullException">The typeName parameter is null.</exception>
            <exception cref="T:System.ArgumentException">The type doesn't implement IMessage, or doesn't
            have a static DefaultMessage property of the same type, or can't be found.</exception>
        </member>
        <member name="T:Google.ProtocolBuffers.NameHelpers">
            <summary>
            Helpers for converting names to pascal case etc.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.NameHelpers.NonAlphaNumericCharacters">
            <summary>
            All characters that are not alpha-numeric
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.NameHelpers.UnderscoreOrNumberWithLowerCase">
            <summary>
            Matches lower-case character that follow either an underscore, or a number
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.NameHelpers.UnderscoresToPascalCase(System.String)">
            <summary>
            Removes non alpha numeric characters while capitalizing letters that follow
            a number or underscore.  The first letter is always upper case.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.NameHelpers.UnderscoresToCamelCase(System.String)">
            <summary>
            Removes non alpha numeric characters while capitalizing letters that follow
            a number or underscore.  The first letter is always lower case.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.NameHelpers.UnderscoresToUpperCase(System.String)">
            <summary>
            Capitalizes any characters following an '_' or a number '0' - '9' and removes
            all non alpha-numeric characters.  If the resulting string begins with a number
            an '_' will be prefixed.  
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.NameHelpers.StripSuffix(System.String@,System.String)">
            <summary>
            Attempts to strip a suffix from a string, returning whether
            or not the suffix was actually present.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.RpcUtil">
            <summary>
            Grab-bag of utility functions useful when dealing with RPCs.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.RpcUtil.SpecializeCallback``1(System.Action{Google.ProtocolBuffers.IMessage})">
            <summary>
            Converts an Action[IMessage] to an Action[T].
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.RpcUtil.GeneralizeCallback``2(System.Action{``0},``0)">
            <summary>
            Converts an Action[T] to an Action[IMessage].
            The generalized action will accept any message object which has
            the same descriptor, and will convert it to the correct class
            before calling the original action. However, if the generalized
            callback is given a message with a different descriptor, an
            exception will be thrown.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.TextFormat">
            <summary>
            Provides ASCII text formatting support for messages.
            TODO(jonskeet): Support for alternative line endings.
            (Easy to print, via TextGenerator. Not sure about parsing.)
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.Print(Google.ProtocolBuffers.IMessage,System.IO.TextWriter)">
            <summary>
            Outputs a textual representation of the Protocol Message supplied into
            the parameter output.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.Print(Google.ProtocolBuffers.IBuilder,System.IO.TextWriter)">
            <summary>
            Outputs a textual representation of the Protocol Message builder supplied into
            the parameter output.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.Print(Google.ProtocolBuffers.UnknownFieldSet,System.IO.TextWriter)">
            <summary>
            Outputs a textual representation of <paramref name="fields" /> to <paramref name="output"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.ParseInteger(System.String,System.Boolean,System.Boolean)">
            <summary>
            Parses an integer in hex (leading 0x), decimal (no prefix) or octal (leading 0).
            Only a negative sign is permitted, and it must come before the radix indicator.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.IsOctal(System.Char)">
            <summary>
            Tests a character to see if it's an octal digit.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.IsHex(System.Char)">
            <summary>
            Tests a character to see if it's a hex digit.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.ParseDigit(System.Char)">
            <summary>
            Interprets a character as a digit (in any base up to 36) and returns the
            numeric value.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.UnescapeText(System.String)">
            <summary>
            Unescapes a text string as escaped using <see cref="M:Google.ProtocolBuffers.TextFormat.EscapeText(System.String)"/>.
            Two-digit hex escapes (starting with "\x" are also recognised.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.EscapeText(System.String)">
            <summary>
            Like <see cref="M:Google.ProtocolBuffers.TextFormat.EscapeBytes(Google.ProtocolBuffers.ByteString)"/> but escapes a text string.
            The string is first encoded as UTF-8, then each byte escaped individually.
            The returned value is guaranteed to be entirely ASCII.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.EscapeBytes(Google.ProtocolBuffers.ByteString)">
            <summary>
            Escapes bytes in the format used in protocol buffer text format, which
            is the same as the format used for C string literals.  All bytes
            that are not printable 7-bit ASCII characters are escaped, as well as
            backslash, single-quote, and double-quote characters.  Characters for
            which no defined short-hand escape sequence is defined will be escaped
            using 3-digit octal sequences.
            The returned value is guaranteed to be entirely ASCII.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.UnescapeBytes(System.String)">
            <summary>
            Performs string unescaping from C style (octal, hex, form feeds, tab etc) into a byte string.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextFormat.MergeField(Google.ProtocolBuffers.TextTokenizer,Google.ProtocolBuffers.ExtensionRegistry,Google.ProtocolBuffers.IBuilder)">
            <summary>
            Parses a single field from the specified tokenizer and merges it into
            the builder.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.TextGenerator">
            <summary>
            Helper class to control indentation. Used for TextFormat and by ProtoGen.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextGenerator.lineBreak">
            <summary>
            The string to use at the end of each line. We assume that "Print" is only called using \n
            to indicate a line break; that's what we use to detect when we need to indent etc, and
            *just* the \n is replaced with the contents of lineBreak.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextGenerator.writer">
            <summary>
            Writer to write formatted text to.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextGenerator.atStartOfLine">
            <summary>
            Keeps track of whether the next piece of text should be indented
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextGenerator.indent">
            <summary>
            Keeps track of the current level of indentation
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextGenerator.#ctor(System.IO.TextWriter,System.String)">
            <summary>
            Creates a generator writing to the given writer. The writer
            is not closed by this class.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextGenerator.Indent">
            <summary>
            Indents text by two spaces. After calling Indent(), two spaces
            will be inserted at the beginning of each line of text. Indent() may
            be called multiple times to produce deeper indents.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextGenerator.Outdent">
            <summary>
            Reduces the current indent level by two spaces.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextGenerator.Print(System.String)">
            <summary>
            Prints the given text to the output stream, indenting at line boundaries.
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Google.ProtocolBuffers.TextTokenizer">
            <summary>
            Represents a stream of tokens parsed from a string.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextTokenizer.matchPos">
            <summary>
            The character index within the text to perform the next regex match at.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextTokenizer.pos">
            <summary>
            The character index within the text at which the current token begins.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextTokenizer.line">
            <summary>
            The line number of the current token.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextTokenizer.column">
            <summary>
            The column number of the current token.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextTokenizer.previousLine">
            <summary>
            The line number of the previous token.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.TextTokenizer.previousColumn">
            <summary>
            The column number of the previous token.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.#ctor(System.String)">
            Construct a tokenizer that parses tokens from the given text. 
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.NextToken">
            <summary>
            Advances to the next token.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.SkipWhitespace">
            <summary>
            Skip over any whitespace so that matchPos starts at the next token.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.TryConsume(System.String)">
            <summary>
            If the next token exactly matches the given token, consume it and return
            true. Otherwise, return false without doing anything.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.Consume(System.String)">
            <summary>
            If the next token exactly matches the specified one, consume it.
            Otherwise, throw a FormatException.
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.LookingAtInteger">
            <summary>
            Returns true if the next token is an integer, but does not consume it.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeIdentifier">
            <summary>
            If the next token is an identifier, consume it and return its value.
            Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeInt32">
            <summary>
            If the next token is a 32-bit signed integer, consume it and return its 
            value. Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeUInt32">
            <summary>
            If the next token is a 32-bit unsigned integer, consume it and return its
            value. Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeInt64">
            <summary>
            If the next token is a 64-bit signed integer, consume it and return its
            value. Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeUInt64">
            <summary>
            If the next token is a 64-bit unsigned integer, consume it and return its
            value. Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeDouble">
            <summary>
            If the next token is a double, consume it and return its value.
            Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeFloat">
            <summary>
            If the next token is a float, consume it and return its value.
            Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeBoolean">
            <summary>
            If the next token is a Boolean, consume it and return its value.
            Otherwise, throw a FormatException.    
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeString">
            <summary>
            If the next token is a string, consume it and return its (unescaped) value.
            Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.ConsumeByteString">
            <summary>
            If the next token is a string, consume it, unescape it as a
            ByteString and return it. Otherwise, throw a FormatException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.CreateFormatException(System.String)">
            <summary>
            Returns a format exception with the current line and column numbers
            in the description, suitable for throwing.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.CreateFormatExceptionPreviousToken(System.String)">
            <summary>
            Returns a format exception with the line and column numbers of the
            previous token in the description, suitable for throwing.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.CreateIntegerParseException(System.FormatException)">
            <summary>
            Constructs an appropriate FormatException for the given existing exception
            when trying to parse an integer.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.TextTokenizer.CreateFloatParseException(System.Exception)">
            <summary>
            Constructs an appropriate FormatException for the given existing exception
            when trying to parse a float or double.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.TextTokenizer.AtEnd">
            <summary>
            Are we at the end of the input?
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.ThrowHelper">
            <summary>
            Helper methods for throwing exceptions
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ThrowHelper.ThrowIfNull(System.Object,System.String)">
            <summary>
            Throws an ArgumentNullException if the given value is null.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ThrowHelper.ThrowIfNull(System.Object)">
            <summary>
            Throws an ArgumentNullException if the given value is null.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.ThrowHelper.ThrowIfAnyNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Throws an ArgumentNullException if the given value or any element within it is null.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.UninitializedMessageException">
            <summary>
            TODO(jonskeet): Write summary text.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UninitializedMessageException.AsInvalidProtocolBufferException">
            <summary>
            Converts this exception into an InvalidProtocolBufferException.
            When a parsed message is missing required fields, this should be thrown
            instead of UninitializedMessageException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UninitializedMessageException.BuildDescription(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs the description string for a given list of missing fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UninitializedMessageException.#ctor(Google.ProtocolBuffers.IMessageLite)">
            <summary>
            For Lite exceptions that do not known how to enumerate missing fields
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UninitializedMessageException.FindMissingFields(Google.ProtocolBuffers.IMessage)">
            <summary>
            Returns a list of the full "paths" of missing required
            fields in the specified message.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UninitializedMessageException.FindMissingFields(Google.ProtocolBuffers.IMessage,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Recursive helper implementing FindMissingFields.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UninitializedMessageException.MissingFields">
            <summary>
            Returns a read-only list of human-readable names of
            required fields missing from this message. Each name
            is a full path to a field, e.g. "foo.bar[5].baz"
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.UnknownField">
            <summary>
            Represents a single field in an UnknownFieldSet.
            
            An UnknownField consists of five lists of values. The lists correspond
            to the five "wire types" used in the protocol buffer binary format.
            The wire type of each field can be determined from the encoded form alone,
            without knowing the field's declared type. So, we are able to parse
            unknown values at least this far and separate them. Normally, only one
            of the five lists will contain any values, since it is impossible to
            define a valid message type that declares two different types for the
            same field number. However, the code is designed to allow for the case
            where the same unknown field number is encountered using multiple different
            wire types.
            
            UnknownField is an immutable class. To construct one, you must use an
            UnknownField.Builder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.CreateBuilder">
            <summary>
            Constructs a new Builder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.CreateBuilder(Google.ProtocolBuffers.UnknownField)">
            <summary>
            Constructs a new Builder and initializes it to a copy of <paramref name="copyFrom"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.WriteTo(System.Int32,Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Serializes the field, including the field number, and writes it to
            <paramref name="output"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.GetSerializedSize(System.Int32)">
            <summary>
            Computes the number of bytes required to encode this field, including field
            number.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.WriteAsMessageSetExtensionTo(System.Int32,Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Serializes the length-delimited values of the field, including field
            number, and writes them to <paramref name="output"/> using the MessageSet wire format.
            </summary>
            <param name="fieldNumber"></param>
            <param name="output"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.GetSerializedSizeAsMessageSetExtension(System.Int32)">
            <summary>
            Get the number of bytes required to encode this field, incuding field number,
            using the MessageSet wire format.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownField.VarintList">
            <summary>
            The list of varint values for this field.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownField.Fixed32List">
            <summary>
            The list of fixed32 values for this field.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownField.Fixed64List">
            <summary>
            The list of fixed64 values for this field.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownField.LengthDelimitedList">
            <summary>
            The list of length-delimited values for this field.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownField.GroupList">
            <summary>
            The list of embedded group values for this field. These
            are represented using UnknownFieldSets rather than Messages
            since the group's type is presumably unknown.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.UnknownField.Builder">
            <summary>
            Used to build instances of UnknownField.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.Build">
            <summary>
            Builds the field. After building, the builder is reset to an empty
            state. (This is actually easier than making it unusable.)
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.MergeFrom(Google.ProtocolBuffers.UnknownField)">
            <summary>
            Merge the values in <paramref name="other" /> into this field.  For each list
            of values, <paramref name="other"/>'s values are append to the ones in this
            field.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.AddAll``1(System.Collections.Generic.List{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Returns a new list containing all of the given specified values from
            both the <paramref name="current"/> and <paramref name="extras"/> lists.
            If <paramref name="current" /> is null and <paramref name="extras"/> is empty,
            null is returned. Otherwise, either a new list is created (if <paramref name="current" />
            is null) or the elements of <paramref name="extras"/> are added to <paramref name="current" />.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.Clear">
            <summary>
            Clears the contents of this builder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.AddVarint(System.UInt64)">
            <summary>
            Adds a varint value.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.AddFixed32(System.UInt32)">
            <summary>
            Adds a fixed32 value.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.AddFixed64(System.UInt64)">
            <summary>
            Adds a fixed64 value.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.AddLengthDelimited(Google.ProtocolBuffers.ByteString)">
            <summary>
            Adds a length-delimited value.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.AddGroup(Google.ProtocolBuffers.UnknownFieldSet)">
            <summary>
            Adds an embedded group.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.Add``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Adds <paramref name="value"/> to the <paramref name="list"/>, creating
            a new list if <paramref name="list"/> is null. The list is returned - either
            the original reference or the new list.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownField.Builder.MakeReadOnly``1(System.Collections.Generic.List{``0}@)">
            <summary>
            Returns a read-only version of the given IList, and clears
            the field used for <paramref name="list"/>. If the value
            is null, an empty list is produced using Lists.Empty.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Google.ProtocolBuffers.UnknownFieldSet">
            <summary>
            Used to keep track of fields which were seen when parsing a protocol message
            but whose field numbers or types are unrecognized. This most frequently
            occurs when new fields are added to a message type and then messages containing
            those fields are read by old software that was built before the new types were
            added.
            
            Every message contains an UnknownFieldSet.
            
            Most users will never need to use this class directly.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.CreateBuilder">
            <summary>
            Creates a new unknown field set builder.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.CreateBuilder(Google.ProtocolBuffers.UnknownFieldSet)">
            <summary>
            Creates a new unknown field set builder 
            and initialize it from <paramref name="original"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.HasField(System.Int32)">
            <summary>
            Checks whether or not the given field number is present in the set.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.WriteTo(Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Serializes the set and writes it to <paramref name="output"/>.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.ToString">
            <summary>
            Converts the set to a string in protocol buffer text format. This
            is just a trivial wrapper around TextFormat.PrintToString.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.PrintTo(System.IO.TextWriter)">
            <summary>
            Converts the set to a string in protocol buffer text format. This
            is just a trivial wrapper around TextFormat.PrintToString.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.ToByteString">
            <summary>
            Serializes the message to a ByteString and returns it. This is
            just a trivial wrapper around WriteTo(ICodedOutputStream).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.ToByteArray">
            <summary>
            Serializes the message to a byte array and returns it. This is
            just a trivial wrapper around WriteTo(ICodedOutputStream).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.WriteTo(System.IO.Stream)">
            <summary>
            Serializes the message and writes it to <paramref name="output"/>. This is
            just a trivial wrapper around WriteTo(ICodedOutputStream).
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.WriteAsMessageSetTo(Google.ProtocolBuffers.ICodedOutputStream)">
            <summary>
            Serializes the set and writes it to <paramref name="output"/> using
            the MessageSet wire format.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.ParseFrom(Google.ProtocolBuffers.ICodedInputStream)">
            <summary>
            Parses an UnknownFieldSet from the given input.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.ParseFrom(Google.ProtocolBuffers.ByteString)">
            <summary>
            Parses an UnknownFieldSet from the given data.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.ParseFrom(System.Byte[])">
            <summary>
            Parses an UnknownFieldSet from the given data.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.ParseFrom(System.IO.Stream)">
            <summary>
            Parses an UnknownFieldSet from the given input.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownFieldSet.FieldDictionary">
            <summary>
            Returns a read-only view of the mapping from field numbers to values.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownFieldSet.Item(System.Int32)">
            <summary>
            Fetches a field by number, returning an empty field if not present.
            Never returns null.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownFieldSet.SerializedSize">
            <summary>
            Gets the number of bytes required to encode this set.
            </summary>
        </member>
        <member name="P:Google.ProtocolBuffers.UnknownFieldSet.SerializedSizeAsMessageSet">
            <summary>
            Gets the number of bytes required to encode this set using the MessageSet
            wire format.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.UnknownFieldSet.Builder">
            <summary>
            Builder for UnknownFieldSets.
            </summary>
        </member>
        <member name="F:Google.ProtocolBuffers.UnknownFieldSet.Builder.fields">
            <summary>
            Mapping from number to field. Note that by using a SortedList we ensure
            that the fields will be serialized in ascending order.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.GetFieldBuilder(System.Int32)">
            <summary>
            Returns a field builder for the specified field number, including any values
            which already exist.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.Build">
            <summary>
            Build the UnknownFieldSet and return it. Once this method has been called,
            this instance will no longer be usable. Calling any method after this
            will throw a NullReferenceException.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.AddField(System.Int32,Google.ProtocolBuffers.UnknownField)">
            <summary>
            Adds a field to the set. If a field with the same number already exists, it
            is replaced.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.Clear">
            <summary>
            Resets the builder to an empty set.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFrom(Google.ProtocolBuffers.ICodedInputStream)">
            <summary>
            Parse an entire message from <paramref name="input"/> and merge
            its fields into this set.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFieldFrom(System.UInt32,Google.ProtocolBuffers.ICodedInputStream)">
            <summary>
            Parse a single field from <paramref name="input"/> and merge it
            into this set.
            </summary>
            <param name="tag">The field's tag number, which was already parsed.</param>
            <param name="input">The coded input stream containing the field</param>
            <returns>false if the tag is an "end group" tag, true otherwise</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFrom(System.IO.Stream)">
            <summary>
            Parses <paramref name="input"/> as an UnknownFieldSet and merge it
            with the set being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFrom(Google.ProtocolBuffers.ByteString)">
            <summary>
            Parses <paramref name="data"/> as an UnknownFieldSet and merge it
            with the set being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFrom(System.Byte[])">
            <summary>
            Parses <paramref name="data"/> as an UnknownFieldSet and merge it
            with the set being built. This is just a small wrapper around
            MergeFrom(ICodedInputStream).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeVarintField(System.Int32,System.UInt64)">
            <summary>
            Convenience method for merging a new field containing a single varint
            value.  This is used in particular when an unknown enum value is
            encountered.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFrom(Google.ProtocolBuffers.UnknownFieldSet)">
            <summary>
            Merges the fields from <paramref name="other"/> into this set.
            If a field number exists in both sets, the values in <paramref name="other"/>
            will be appended to the values in this set.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.HasField(System.Int32)">
            <summary>
            Checks if the given field number is present in the set.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeField(System.Int32,Google.ProtocolBuffers.UnknownField)">
            <summary>
            Adds a field to the unknown field set. If a field with the same
            number already exists, the two are merged.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFieldFrom(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry,Google.ProtocolBuffers.IBuilder,System.UInt32,System.String)">
            <summary>
            Like <see cref="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeFrom(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry,Google.ProtocolBuffers.IBuilder)"/>
            but parses a single field.
            </summary>
            <param name="input">The input to read the field from</param>
            <param name="extensionRegistry">Registry to use when an extension field is encountered</param>
            <param name="builder">Builder to merge field into, if it's a known field</param>
            <param name="tag">The tag, which should already have been read from the input</param>
            <returns>true unless the tag is an end-group tag</returns>
        </member>
        <member name="M:Google.ProtocolBuffers.UnknownFieldSet.Builder.MergeMessageSetExtensionFromCodedStream(Google.ProtocolBuffers.ICodedInputStream,Google.ProtocolBuffers.ExtensionRegistry,Google.ProtocolBuffers.IBuilder)">
            <summary>
            Called by MergeFieldFrom to parse a MessageSet extension.
            </summary>
        </member>
        <member name="T:Google.ProtocolBuffers.WireFormat">
            <summary>
            This class is used internally by the Protocol Buffer Library and generated
            message implementations. It is public only for the sake of those generated
            messages. Others should not use this class directly.
            <para>
            This class contains constants and helper functions useful for dealing with
            the Protocol Buffer wire format.
            </para>
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.WireFormat.GetTagWireType(System.UInt32)">
            <summary>
            Given a tag value, determines the wire type (lower 3 bits).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.WireFormat.GetTagFieldNumber(System.UInt32)">
            <summary>
            Given a tag value, determines the field number (the upper 29 bits).
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.WireFormat.MakeTag(System.Int32,Google.ProtocolBuffers.WireFormat.WireType)">
            <summary>
            Makes a tag value given a field number and wire type.
            TODO(jonskeet): Should we just have a Tag structure?
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.WireFormat.GetWireType(Google.ProtocolBuffers.Descriptors.FieldDescriptor)">
            <summary>
            Returns the wire type for the given field descriptor. This differs
            from GetWireType(FieldType) for packed repeated fields.
            </summary>
        </member>
        <member name="M:Google.ProtocolBuffers.WireFormat.GetWireType(Google.ProtocolBuffers.Descriptors.FieldType)">
            <summary>
            Converts a field type to its wire type. Done with a switch for the sake
            of speed - this is significantly faster than a dictionary lookup.
            </summary>
        </member>
    </members>
</doc>
